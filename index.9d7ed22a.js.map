{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./node_modules/@parcel/runtime-js/lib/bundle-manifest.js","./node_modules/@parcel/runtime-js/lib/JSRuntime.js","./node_modules/@logux/core/log/index.js","./node_modules/nanoevents/index.js","./node_modules/@logux/core/is-first-older/index.js","./node_modules/@logux/core/ws-connection/index.js","./node_modules/@logux/core/memory-store/index.js","./node_modules/@logux/core/logux-error/index.js","./node_modules/@logux/core/connect/index.js","./node_modules/@logux/core/base-node/index.js","./node_modules/@logux/core/sync/index.js","./node_modules/@logux/core/ping/index.js","./node_modules/@logux/core/debug/index.js","./node_modules/@logux/core/error/index.js","./node_modules/@logux/core/headers/index.js","./node_modules/@logux/core/client-node/index.js","./node_modules/@logux/core/local-pair/index.js","./node_modules/@logux/core/reconnect/index.js","./node_modules/@logux/core/parse-id/index.js","./status/index.js","./badge/index.js","./node_modules/nanoid/index.browser.js","./logux-undo-error/index.js","./client/index.js","./cross-tab-client/index.js","./confirm/index.js","./log/index.js","./node_modules/@parcel/runtime-js/lib/bundle-url.js","./node_modules/@parcel/runtime-js/lib/relative-path.js","./badge/styles/index.js","./test/demo/index.js","./track/index.js","./attention/index.js","./favicon/index.js"],"sourcesContent":["var $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$export(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n","\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _plugin() {\n  const data = require(\"@parcel/plugin\");\n\n  _plugin = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _utils() {\n  const data = require(\"@parcel/utils\");\n\n  _utils = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _nullthrows() {\n  const data = _interopRequireDefault(require(\"nullthrows\"));\n\n  _nullthrows = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// List of browsers that support dynamic import natively\n// https://caniuse.com/#feat=es6-module-dynamic-import\nconst DYNAMIC_IMPORT_BROWSERS = {\n  edge: '76',\n  firefox: '67',\n  chrome: '63',\n  safari: '11.1',\n  opera: '50'\n}; // Used for as=\"\" in preload/prefetch\n\nconst TYPE_TO_RESOURCE_PRIORITY = {\n  css: 'style',\n  js: 'script'\n};\nconst BROWSER_PRELOAD_LOADER = './loaders/browser/preload-loader';\nconst BROWSER_PREFETCH_LOADER = './loaders/browser/prefetch-loader';\nconst LOADERS = {\n  browser: {\n    css: './loaders/browser/css-loader',\n    html: './loaders/browser/html-loader',\n    js: './loaders/browser/js-loader',\n    wasm: './loaders/browser/wasm-loader',\n    IMPORT_POLYFILL: './loaders/browser/import-polyfill'\n  },\n  worker: {\n    js: './loaders/worker/js-loader',\n    wasm: './loaders/worker/wasm-loader',\n    IMPORT_POLYFILL: false\n  },\n  node: {\n    css: './loaders/node/css-loader',\n    html: './loaders/node/html-loader',\n    js: './loaders/node/js-loader',\n    wasm: './loaders/node/wasm-loader',\n    IMPORT_POLYFILL: null\n  }\n};\n\nfunction getLoaders(ctx) {\n  if (ctx.isWorker()) return LOADERS.worker;\n  if (ctx.isBrowser()) return LOADERS.browser;\n  if (ctx.isNode()) return LOADERS.node;\n  return null;\n} // This cache should be invalidated if new dependencies get added to the bundle without the bundle objects changing\n// This can happen when we reuse the BundleGraph between subsequent builds\n\n\nlet bundleDependencies = new WeakMap();\n\nvar _default = new (_plugin().Runtime)({\n  apply({\n    bundle,\n    bundleGraph,\n    options\n  }) {\n    // Dependency ids in code replaced with referenced bundle names\n    // Loader runtime added for bundle groups that don't have a native loader (e.g. HTML/CSS/Worker - isURL?),\n    // and which are not loaded by a parent bundle.\n    // Loaders also added for modules that were moved to a separate bundle because they are a different type\n    // (e.g. WASM, HTML). These should be preloaded prior to the bundle being executed. Replace the entry asset(s)\n    // with the preload module.\n    if (bundle.type !== 'js') {\n      return;\n    }\n\n    let {\n      asyncDependencies,\n      otherDependencies\n    } = getDependencies(bundle);\n    let assets = [];\n\n    for (let dependency of asyncDependencies) {\n      let resolved = bundleGraph.resolveAsyncDependency(dependency, bundle);\n\n      if (resolved == null) {\n        continue;\n      }\n\n      if (resolved.type === 'asset') {\n        if (!bundle.env.shouldScopeHoist) {\n          // If this bundle already has the asset this dependency references,\n          // return a simple runtime of `Promise.resolve(internalRequire(assetId))`.\n          // The linker handles this for scope-hoisting.\n          assets.push({\n            filePath: __filename,\n            code: `module.exports = Promise.resolve(module.bundle.root(${JSON.stringify(bundleGraph.getAssetPublicId(resolved.value))}))`,\n            dependency\n          });\n        }\n      } else {\n        let loaderRuntime = getLoaderRuntime({\n          bundle,\n          dependency,\n          bundleGraph,\n          bundleGroup: resolved.value,\n          options\n        });\n\n        if (loaderRuntime != null) {\n          assets.push(loaderRuntime);\n        }\n      }\n    }\n\n    for (let dependency of otherDependencies) {\n      // Resolve the dependency to a bundle. If inline, export the dependency id,\n      // which will be replaced with the contents of that bundle later.\n      let referencedBundle = bundleGraph.getReferencedBundle(dependency, bundle);\n\n      if (referencedBundle !== null && referencedBundle !== void 0 && referencedBundle.isInline) {\n        assets.push({\n          filePath: _path().default.join(__dirname, `/bundles/${referencedBundle.id}.js`),\n          code: `module.exports = ${JSON.stringify(dependency.id)};`,\n          dependency\n        });\n        continue;\n      } // Otherwise, try to resolve the dependency to an external bundle group\n      // and insert a URL to that bundle.\n\n\n      let resolved = bundleGraph.resolveAsyncDependency(dependency, bundle);\n\n      if (dependency.isURL && resolved == null) {\n        // If a URL dependency was not able to be resolved, add a runtime that\n        // exports the original moduleSpecifier.\n        assets.push({\n          filePath: __filename,\n          code: `module.exports = ${JSON.stringify(dependency.moduleSpecifier)}`,\n          dependency\n        });\n        continue;\n      }\n\n      if (resolved == null || resolved.type !== 'bundle_group') {\n        continue;\n      }\n\n      let bundleGroup = resolved.value;\n      let mainBundle = (0, _nullthrows().default)(bundleGraph.getBundlesInBundleGroup(bundleGroup).find(b => {\n        let entries = b.getEntryAssets();\n        return entries.some(e => bundleGroup.entryAssetId === e.id);\n      }));\n\n      if (bundle.env.outputFormat === 'commonjs' && mainBundle.type === 'js') {\n        assets.push({\n          filePath: __filename,\n          dependency,\n          code: `module.exports = require(\"./\" + ${getRelativePathExpr(bundle, mainBundle, options)})`\n        });\n        continue;\n      } // URL dependency or not, fall back to including a runtime that exports the url\n\n\n      assets.push(getURLRuntime(dependency, bundle, mainBundle, options));\n    } // In development, bundles can be created lazily. This means that the parent bundle may not\n    // know about all of the sibling bundles of a child when it is written for the first time.\n    // Therefore, we need to also ensure that the siblings are loaded when the child loads.\n\n\n    if (options.shouldBuildLazily && bundle.env.outputFormat === 'global') {\n      let referenced = bundleGraph.getReferencedBundles(bundle).filter(b => !b.isInline);\n\n      for (let referencedBundle of referenced) {\n        let loaders = getLoaders(bundle.env);\n\n        if (!loaders) {\n          continue;\n        }\n\n        let loader = loaders[referencedBundle.type];\n\n        if (!loader) {\n          continue;\n        }\n\n        let relativePathExpr = getRelativePathExpr(bundle, referencedBundle, options);\n        let loaderCode = `require(${JSON.stringify(loader)})(require('./bundle-url').getBundleURL() + ${relativePathExpr})`;\n        assets.push({\n          filePath: __filename,\n          code: loaderCode,\n          isEntry: true\n        });\n      }\n    }\n\n    if (shouldUseRuntimeManifest(bundle, options) && bundleGraph.getChildBundles(bundle).length > 0 && isNewContext(bundle, bundleGraph)) {\n      assets.push({\n        filePath: __filename,\n        code: getRegisterCode(bundle, bundleGraph),\n        isEntry: true\n      });\n    }\n\n    return assets;\n  }\n\n});\n\nexports.default = _default;\n\nfunction getDependencies(bundle) {\n  let cachedDependencies = bundleDependencies.get(bundle);\n\n  if (cachedDependencies) {\n    return cachedDependencies;\n  } else {\n    let asyncDependencies = [];\n    let otherDependencies = [];\n    bundle.traverse(node => {\n      if (node.type !== 'dependency') {\n        return;\n      }\n\n      let dependency = node.value;\n\n      if (dependency.isAsync && !dependency.isURL) {\n        asyncDependencies.push(dependency);\n      } else {\n        otherDependencies.push(dependency);\n      }\n    });\n    bundleDependencies.set(bundle, {\n      asyncDependencies,\n      otherDependencies\n    });\n    return {\n      asyncDependencies,\n      otherDependencies\n    };\n  }\n}\n\nfunction getLoaderRuntime({\n  bundle,\n  dependency,\n  bundleGroup,\n  bundleGraph,\n  options\n}) {\n  let loaders = getLoaders(bundle.env);\n\n  if (loaders == null) {\n    return;\n  }\n\n  let externalBundles = bundleGraph.getBundlesInBundleGroup(bundleGroup).filter(bundle => !bundle.isInline);\n  let mainBundle = (0, _nullthrows().default)(externalBundles.find(bundle => {\n    var _bundle$getMainEntry;\n\n    return ((_bundle$getMainEntry = bundle.getMainEntry()) === null || _bundle$getMainEntry === void 0 ? void 0 : _bundle$getMainEntry.id) === bundleGroup.entryAssetId;\n  })); // CommonJS is a synchronous module system, so there is no need to load bundles in parallel.\n  // Importing of the other bundles will be handled by the bundle group entry.\n  // Do the same thing in library mode for ES modules, as we are building for another bundler\n  // and the imports for sibling bundles will be in the target bundle.\n  // Also do this when building lazily or the runtime itself could get deduplicated and only\n  // exist in the parent. This causes errors if an old version of the parent without the runtime\n  // is already loaded.\n\n  if (bundle.env.outputFormat === 'commonjs' || bundle.env.isLibrary || options.shouldBuildLazily) {\n    externalBundles = [mainBundle];\n  } else {\n    // Otherwise, load the bundle group entry after the others.\n    externalBundles.splice(externalBundles.indexOf(mainBundle), 1);\n    externalBundles.reverse().push(mainBundle);\n  } // Determine if we need to add a dynamic import() polyfill, or if all target browsers support it natively.\n\n\n  let needsDynamicImportPolyfill = false;\n\n  if (bundle.env.isBrowser() && bundle.env.outputFormat === 'esmodule') {\n    needsDynamicImportPolyfill = !bundle.env.matchesEngines(DYNAMIC_IMPORT_BROWSERS);\n  }\n\n  let loaderModules = externalBundles.map(to => {\n    let loader = loaders[to.type];\n\n    if (!loader) {\n      return;\n    }\n\n    let relativePathExpr = getRelativePathExpr(bundle, to, options); // Use esmodule loader if possible\n\n    if (to.type === 'js' && to.env.outputFormat === 'esmodule') {\n      if (!needsDynamicImportPolyfill) {\n        return `import(\"./\" + ${relativePathExpr})`;\n      }\n\n      loader = (0, _nullthrows().default)(loaders.IMPORT_POLYFILL, `No import() polyfill available for context '${bundle.env.context}'`);\n    } else if (to.type === 'js' && to.env.outputFormat === 'commonjs') {\n      return `Promise.resolve(require(\"./\" + ${relativePathExpr}))`;\n    }\n\n    let code = `require(${JSON.stringify(loader)})(require('./bundle-url').getBundleURL() + ${relativePathExpr})`; // In development, clear the require cache when an error occurs so the\n    // user can try again (e.g. after fixing a build error).\n\n    if (options.mode === 'development' && bundle.env.outputFormat === 'global') {\n      code += '.catch(err => {delete module.bundle.cache[module.id]; throw err;})';\n    }\n\n    return code;\n  }).filter(Boolean);\n\n  if (bundle.env.context === 'browser' && !options.shouldBuildLazily) {\n    loaderModules.push(...externalBundles // TODO: Allow css to preload resources as well\n    .filter(to => to.type === 'js').flatMap(from => {\n      let {\n        preload,\n        prefetch\n      } = getHintedBundleGroups(bundleGraph, from);\n      return [...getHintLoaders(bundleGraph, bundle, preload, BROWSER_PRELOAD_LOADER, options), ...getHintLoaders(bundleGraph, bundle, prefetch, BROWSER_PREFETCH_LOADER, options)];\n    }));\n  }\n\n  if (loaderModules.length === 0) {\n    return;\n  }\n\n  let loaderCode = loaderModules.join(', ');\n\n  if (loaderModules.length > 1 && (bundle.env.outputFormat === 'global' || !externalBundles.every(b => b.type === 'js'))) {\n    loaderCode = `Promise.all([${loaderCode}])`;\n\n    if (bundle.env.outputFormat !== 'global') {\n      loaderCode += `.then(r => r[r.length - 1])`;\n    }\n  } else {\n    loaderCode = `(${loaderCode})`;\n  }\n\n  if (bundle.env.outputFormat === 'global' && mainBundle.type === 'js') {\n    loaderCode += `.then(() => module.bundle.root('${bundleGraph.getAssetPublicId(bundleGraph.getAssetById(bundleGroup.entryAssetId))}')${// In global output with scope hoisting, functions return exports are\n    // always returned. Otherwise, the exports are returned.\n    bundle.env.shouldScopeHoist ? '()' : ''})`;\n  }\n\n  return {\n    filePath: __filename,\n    code: `module.exports = ${loaderCode};`,\n    dependency\n  };\n}\n\nfunction getHintedBundleGroups(bundleGraph, bundle) {\n  let preload = [];\n  let prefetch = [];\n  let {\n    asyncDependencies\n  } = getDependencies(bundle);\n\n  for (let dependency of asyncDependencies) {\n    var _dependency$meta;\n\n    let attributes = (_dependency$meta = dependency.meta) === null || _dependency$meta === void 0 ? void 0 : _dependency$meta.importAttributes;\n\n    if (typeof attributes === 'object' && attributes != null && ( // $FlowFixMe\n    attributes.preload || attributes.prefetch)) {\n      let resolved = bundleGraph.resolveAsyncDependency(dependency, bundle);\n\n      if ((resolved === null || resolved === void 0 ? void 0 : resolved.type) === 'bundle_group') {\n        // === true for flow\n        if (attributes.preload === true) {\n          preload.push(resolved.value);\n        }\n\n        if (attributes.prefetch === true) {\n          prefetch.push(resolved.value);\n        }\n      }\n    }\n  }\n\n  return {\n    preload,\n    prefetch\n  };\n}\n\nfunction getHintLoaders(bundleGraph, from, bundleGroups, loader, options) {\n  let hintLoaders = [];\n\n  for (let bundleGroupToPreload of bundleGroups) {\n    let bundlesToPreload = bundleGraph.getBundlesInBundleGroup(bundleGroupToPreload);\n\n    for (let bundleToPreload of bundlesToPreload) {\n      let relativePathExpr = getRelativePathExpr(from, bundleToPreload, options);\n      let priority = TYPE_TO_RESOURCE_PRIORITY[bundleToPreload.type];\n      hintLoaders.push(`require(${JSON.stringify(loader)})(require('./bundle-url').getBundleURL() + ${relativePathExpr}, ${priority ? JSON.stringify(priority) : 'null'}, ${JSON.stringify(bundleToPreload.target.env.outputFormat === 'esmodule')})`);\n    }\n  }\n\n  return hintLoaders;\n}\n\nfunction isNewContext(bundle, bundleGraph) {\n  let parents = bundleGraph.getParentBundles(bundle);\n  return bundle.isEntry || parents.length === 0 || parents.some(parent => parent.env.context !== bundle.env.context || parent.type !== 'js');\n}\n\nfunction getURLRuntime(dependency, from, to, options) {\n  let relativePathExpr = getRelativePathExpr(from, to, options);\n\n  if (dependency.meta.webworker === true) {\n    return {\n      filePath: __filename,\n      code: `module.exports = require('./get-worker-url')(${relativePathExpr});`,\n      dependency\n    };\n  }\n\n  return {\n    filePath: __filename,\n    code: `module.exports = require('./bundle-url').getBundleURL() + ${relativePathExpr}`,\n    dependency\n  };\n}\n\nfunction getRegisterCode(entryBundle, bundleGraph) {\n  let idToName = {};\n  bundleGraph.traverseBundles((bundle, _, actions) => {\n    if (bundle.isInline) {\n      return;\n    }\n\n    idToName[bundle.publicId] = (0, _nullthrows().default)(bundle.name);\n\n    if (bundle !== entryBundle && isNewContext(bundle, bundleGraph)) {\n      // New contexts have their own manifests, so there's no need to continue.\n      actions.skipChildren();\n    }\n  }, entryBundle);\n  return \"require('./bundle-manifest').register(JSON.parse(\" + JSON.stringify(JSON.stringify(idToName)) + '));';\n}\n\nfunction getRelativePathExpr(from, to, options) {\n  if (shouldUseRuntimeManifest(from, options)) {\n    return `require('./relative-path')(${JSON.stringify(from.publicId)}, ${JSON.stringify(to.publicId)})`;\n  }\n\n  return JSON.stringify((0, _utils().relativeBundlePath)(from, to, {\n    leadingDotSlash: false\n  }));\n}\n\nfunction shouldUseRuntimeManifest(bundle, options) {\n  let env = bundle.env;\n  return !env.isLibrary && env.outputFormat === 'global' && env.isBrowser() && options.mode === 'production';\n}","import { createNanoEvents } from 'nanoevents'\n\nexport function actionEvents(emitter, event, action, meta) {\n  if (action.id) {\n    emitter.emit(`${event}-${action.type}-${action.id}`, action, meta)\n  }\n  emitter.emit(`${event}-${action.type}-`, action, meta)\n  emitter.emit(event, action, meta)\n}\n\nexport class Log {\n  constructor(opts = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof opts.nodeId === 'undefined') {\n        throw new Error('Expected node ID')\n      }\n      if (typeof opts.store !== 'object') {\n        throw new Error('Expected store')\n      }\n      if (opts.nodeId.includes(' ')) {\n        throw new Error('Space is prohibited in node ID')\n      }\n    }\n\n    this.nodeId = opts.nodeId\n\n    this.lastTime = 0\n    this.sequence = 0\n\n    this.store = opts.store\n\n    this.emitter = createNanoEvents()\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  type(type, listener, opts = {}) {\n    let event = opts.event || 'add'\n    let id = opts.id || ''\n    return this.emitter.on(`${event}-${type}-${id}`, listener)\n  }\n\n  async add(action, meta = {}) {\n    if (typeof action.type === 'undefined') {\n      throw new Error('Expected \"type\" in action')\n    }\n\n    let newId = false\n    if (typeof meta.id === 'undefined') {\n      newId = true\n      meta.id = this.generateId()\n    }\n\n    if (typeof meta.time === 'undefined') {\n      meta.time = parseInt(meta.id)\n    }\n\n    if (typeof meta.reasons === 'undefined') {\n      meta.reasons = []\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(meta.reasons)) {\n        throw new Error('Expected \"reasons\" to be an array of strings')\n      }\n\n      for (let reason of meta.reasons) {\n        if (typeof reason !== 'string') {\n          throw new Error('Expected \"reasons\" to be an array of strings')\n        }\n      }\n\n      if (typeof meta.indexes !== 'undefined') {\n        if (!Array.isArray(meta.indexes)) {\n          throw new Error('Expected \"indexes\" to be an array of strings')\n        }\n\n        for (let index of meta.indexes) {\n          if (typeof index !== 'string') {\n            throw new Error('Expected \"indexes\" to be an array of strings')\n          }\n        }\n      }\n    }\n\n    actionEvents(this.emitter, 'preadd', action, meta)\n\n    if (meta.keepLast) {\n      this.removeReason(meta.keepLast, { olderThan: meta })\n      meta.reasons.push(meta.keepLast)\n    }\n\n    if (meta.reasons.length === 0 && newId) {\n      actionEvents(this.emitter, 'add', action, meta)\n      actionEvents(this.emitter, 'clean', action, meta)\n      return meta\n    } else if (meta.reasons.length === 0) {\n      let [action2] = await this.store.byId(meta.id)\n      if (action2) {\n        return false\n      } else {\n        actionEvents(this.emitter, 'add', action, meta)\n        actionEvents(this.emitter, 'clean', action, meta)\n        return meta\n      }\n    } else {\n      let addedMeta = await this.store.add(action, meta)\n      if (addedMeta === false) {\n        return false\n      } else {\n        actionEvents(this.emitter, 'add', action, meta)\n        return addedMeta\n      }\n    }\n  }\n\n  generateId() {\n    let now = Date.now()\n    if (now <= this.lastTime) {\n      now = this.lastTime\n      this.sequence += 1\n    } else {\n      this.lastTime = now\n      this.sequence = 0\n    }\n    return now + ' ' + this.nodeId + ' ' + this.sequence\n  }\n\n  each(opts, callback) {\n    if (!callback) {\n      callback = opts\n      opts = { order: 'created' }\n    }\n\n    let store = this.store\n    return new Promise(resolve => {\n      async function nextPage(get) {\n        let page = await get()\n        let result\n        for (let i = page.entries.length - 1; i >= 0; i--) {\n          let entry = page.entries[i]\n          result = callback(entry[0], entry[1])\n          if (result === false) break\n        }\n\n        if (result === false || !page.next) {\n          resolve()\n        } else {\n          nextPage(page.next)\n        }\n      }\n\n      nextPage(store.get.bind(store, opts))\n    })\n  }\n\n  async changeMeta(id, diff) {\n    for (let k in diff) {\n      if (\n        k === 'id' ||\n        k === 'added' ||\n        k === 'time' ||\n        k === 'subprotocol' ||\n        k === 'indexes'\n      ) {\n        throw new Error('Meta \"' + k + '\" is read-only')\n      }\n    }\n\n    if (diff.reasons && diff.reasons.length === 0) {\n      let entry = await this.store.remove(id)\n      if (entry) {\n        for (let k in diff) entry[1][k] = diff[k]\n        actionEvents(this.emitter, 'clean', entry[0], entry[1])\n      }\n      return !!entry\n    } else {\n      return this.store.changeMeta(id, diff)\n    }\n  }\n\n  removeReason(reason, criteria = {}) {\n    return this.store.removeReason(reason, criteria, (action, meta) => {\n      actionEvents(this.emitter, 'clean', action, meta)\n    })\n  }\n\n  byId(id) {\n    return this.store.byId(id)\n  }\n}\n","export let createNanoEvents = () => ({\n  events: {},\n  emit(event, ...args) {\n    ;(this.events[event] || []).forEach(i => i(...args))\n  },\n  on(event, cb) {\n    ;(this.events[event] = this.events[event] || []).push(cb)\n    return () =>\n      (this.events[event] = (this.events[event] || []).filter(i => i !== cb))\n  }\n})\n","export function isFirstOlder(firstMeta, secondMeta) {\n  if (firstMeta && !secondMeta) {\n    return false\n  } else if (!firstMeta && secondMeta) {\n    return true\n  }\n\n  if (firstMeta.time > secondMeta.time) {\n    return false\n  } else if (firstMeta.time < secondMeta.time) {\n    return true\n  }\n\n  let first = firstMeta.id.split(' ')\n  let second = secondMeta.id.split(' ')\n\n  let firstNode = first[1]\n  let secondNode = second[1]\n  if (firstNode > secondNode) {\n    return false\n  } else if (firstNode < secondNode) {\n    return true\n  }\n\n  let firstCounter = parseInt(first[2])\n  let secondCounter = parseInt(second[2])\n  if (firstCounter > secondCounter) {\n    return false\n  } else if (firstCounter < secondCounter) {\n    return true\n  }\n\n  let firstNodeTime = parseInt(first[0])\n  let secondNodeTime = parseInt(second[0])\n  if (firstNodeTime > secondNodeTime) {\n    return false\n  } else if (firstNodeTime < secondNodeTime) {\n    return true\n  }\n\n  return false\n}\n","import { createNanoEvents } from 'nanoevents'\n\nexport class WsConnection {\n  constructor(url, Class, opts) {\n    this.connected = false\n    this.emitter = createNanoEvents()\n    if (Class) {\n      this.Class = Class\n    } else if (typeof WebSocket !== 'undefined') {\n      this.Class = WebSocket\n    } else {\n      throw new Error('No WebSocket support')\n    }\n    this.url = url\n    this.opts = opts\n  }\n\n  init(ws) {\n    ws.onerror = event => {\n      this.emitter.emit('error', event.error || new Error('WS Error'))\n    }\n\n    ws.onclose = () => {\n      this.onclose()\n    }\n\n    ws.onmessage = event => {\n      let data\n      try {\n        data = JSON.parse(event.data)\n      } catch {\n        this.error(event.data)\n        return\n      }\n      this.emitter.emit('message', data)\n    }\n\n    this.ws = ws\n  }\n\n  connect() {\n    if (this.ws) return Promise.resolve()\n\n    this.emitter.emit('connecting')\n    this.init(new this.Class(this.url, undefined, this.opts))\n\n    return new Promise(resolve => {\n      this.ws.onopen = () => {\n        this.connected = true\n        this.emitter.emit('connect')\n        resolve()\n      }\n    })\n  }\n\n  disconnect() {\n    if (this.ws) {\n      this.ws.onclose = undefined\n      this.ws.close()\n      this.onclose()\n    }\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  send(message) {\n    if (this.ws && this.ws.readyState === this.ws.OPEN) {\n      this.ws.send(JSON.stringify(message))\n    } else {\n      this.emitter.emit('error', new Error('WS was closed'))\n    }\n  }\n\n  error(message) {\n    let err = new Error('Wrong message format')\n    err.received = message\n    this.emitter.emit('error', err)\n  }\n\n  onclose() {\n    if (this.ws) {\n      this.connected = false\n      this.emitter.emit('disconnect')\n      this.ws = undefined\n    }\n  }\n}\n","import { isFirstOlder } from '../is-first-older/index.js'\n\nfunction checkIndex(store, index) {\n  if (!store.indexes[index]) {\n    store.indexes[index] = { added: [], entries: [] }\n  }\n}\n\nfunction forEachIndex(meta, cb) {\n  let indexes = meta.indexes\n  if (isDefined(indexes) && indexes.length > 0) {\n    for (let index of indexes) {\n      cb(index)\n    }\n  }\n}\n\nfunction insert(store, entry) {\n  store.lastAdded += 1\n  entry[1].added = store.lastAdded\n  store.added.push(entry)\n  forEachIndex(entry[1], index => {\n    checkIndex(store, index)\n    store.indexes[index].added.push(entry)\n  })\n  return Promise.resolve(entry[1])\n}\n\nfunction eject(store, meta) {\n  let added = meta.added\n  let start = 0\n  let end = store.added.length - 1\n  while (start <= end) {\n    let middle = (end + start) >> 1\n    let otherAdded = store.added[middle][1].added\n    if (otherAdded < added) {\n      start = middle + 1\n    } else if (otherAdded > added) {\n      end = middle - 1\n    } else {\n      store.added.splice(middle, 1)\n      break\n    }\n  }\n}\n\nfunction find(list, id) {\n  for (let i = list.length - 1; i >= 0; i--) {\n    if (id === list[i][1].id) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction isDefined(value) {\n  return typeof value !== 'undefined'\n}\n\nexport class MemoryStore {\n  constructor() {\n    this.entries = []\n    this.added = []\n    this.indexes = {}\n    this.lastReceived = 0\n    this.lastAdded = 0\n    this.lastSent = 0\n  }\n\n  async add(action, meta) {\n    let entry = [action, meta]\n    let id = meta.id\n\n    let list = this.entries\n    for (let i = 0; i < list.length; i++) {\n      let [, otherMeta] = list[i]\n      if (id === otherMeta.id) {\n        return false\n      } else if (!isFirstOlder(otherMeta, meta)) {\n        forEachIndex(meta, index => {\n          checkIndex(this, index)\n          let indexList = this.indexes[index].entries\n          let j = indexList.findIndex(item => !isFirstOlder(item[1], meta))\n          indexList.splice(j, 0, entry)\n        })\n        list.splice(i, 0, entry)\n        return insert(this, entry)\n      }\n    }\n\n    forEachIndex(meta, index => {\n      checkIndex(this, index)\n      this.indexes[index].entries.push(entry)\n    })\n    list.push(entry)\n    return insert(this, entry)\n  }\n\n  async byId(id) {\n    let created = find(this.entries, id)\n    if (created === -1) {\n      return [null, null]\n    } else {\n      let [action, meta] = this.entries[created]\n      return [action, meta]\n    }\n  }\n\n  async remove(id, created) {\n    if (typeof created === 'undefined') {\n      created = find(this.entries, id)\n      if (created === -1) return Promise.resolve(false)\n    }\n\n    let entry = [this.entries[created][0], this.entries[created][1]]\n    forEachIndex(entry[1], index => {\n      let entries = this.indexes[index].entries\n      let indexed = find(entries, id)\n      if (indexed !== -1) entries.splice(indexed, 1)\n    })\n    this.entries.splice(created, 1)\n\n    forEachIndex(entry[1], index => {\n      eject(this.indexes[index], entry[1])\n    })\n    eject(this, entry[1])\n\n    return entry\n  }\n\n  async get(opts = {}) {\n    let index = opts.index\n    let store = this\n    let entries\n    if (index) {\n      store = this.indexes[index] || { added: [], entries: [] }\n    }\n    if (opts.order === 'created') {\n      entries = store.entries\n    } else {\n      entries = store.added\n    }\n    return { entries: entries.slice(0) }\n  }\n\n  async changeMeta(id, diff) {\n    let index = find(this.entries, id)\n    if (index === -1) {\n      return false\n    } else {\n      let meta = this.entries[index][1]\n      for (let key in diff) meta[key] = diff[key]\n      return true\n    }\n  }\n\n  async removeReason(reason, criteria, callback) {\n    let removed = []\n\n    if (criteria.id) {\n      let index = find(this.entries, criteria.id)\n      if (index !== -1) {\n        let meta = this.entries[index][1]\n        let reasonPos = meta.reasons.indexOf(reason)\n        if (reasonPos !== -1) {\n          meta.reasons.splice(reasonPos, 1)\n          if (meta.reasons.length === 0) {\n            callback(this.entries[index][0], meta)\n            this.remove(criteria.id)\n          }\n        }\n      }\n    } else {\n      this.entries = this.entries.filter(([action, meta]) => {\n        let c = criteria\n\n        let reasonPos = meta.reasons.indexOf(reason)\n        if (reasonPos === -1) {\n          return true\n        }\n        if (isDefined(c.olderThan) && !isFirstOlder(meta, c.olderThan)) {\n          return true\n        }\n        if (isDefined(c.youngerThan) && !isFirstOlder(c.youngerThan, meta)) {\n          return true\n        }\n        if (isDefined(c.minAdded) && meta.added < c.minAdded) {\n          return true\n        }\n        if (isDefined(c.maxAdded) && meta.added > c.maxAdded) {\n          return true\n        }\n\n        meta.reasons.splice(reasonPos, 1)\n        if (meta.reasons.length === 0) {\n          callback(action, meta)\n          removed.push(meta)\n          return false\n        } else {\n          return true\n        }\n      })\n\n      let removedAdded = removed.map(m => m.added)\n      let removing = i => !removedAdded.includes(i[1].added)\n      this.added = this.added.filter(removing)\n\n      for (let meta of removed) {\n        forEachIndex(meta, i => {\n          this.indexes[i].entries = this.indexes[i].entries.filter(removing)\n          this.indexes[i].added = this.indexes[i].added.filter(removing)\n        })\n      }\n    }\n  }\n\n  async clean() {\n    this.entries = []\n    this.added = []\n    this.indexes = {}\n    this.lastReceived = 0\n    this.lastAdded = 0\n    this.lastSent = 0\n  }\n\n  async getLastAdded() {\n    return this.lastAdded\n  }\n\n  async getLastSynced() {\n    return {\n      received: this.lastReceived,\n      sent: this.lastSent\n    }\n  }\n\n  async setLastSynced(values) {\n    if (typeof values.sent !== 'undefined') {\n      this.lastSent = values.sent\n    }\n    if (typeof values.received !== 'undefined') {\n      this.lastReceived = values.received\n    }\n  }\n}\n","export class LoguxError extends Error {\n  static describe(type, options) {\n    if (type === 'timeout') {\n      return 'A timeout was reached (' + options + ' ms)'\n    } else if (type === 'wrong-format') {\n      return 'Wrong message format in ' + options\n    } else if (type === 'unknown-message') {\n      return 'Unknown message `' + options + '` type'\n    } else if (type === 'bruteforce') {\n      return 'Too many wrong authentication attempts'\n    } else if (type === 'wrong-protocol') {\n      return (\n        `Logux supports protocols only from version ${options.supported}` +\n        `, but you use ${options.used}`\n      )\n    } else if (type === 'wrong-subprotocol') {\n      return (\n        `Only ${options.supported} application subprotocols are ` +\n        `supported, but you use ${options.used}`\n      )\n    } else if (type === 'wrong-credentials') {\n      return 'Wrong credentials'\n    } else {\n      return type\n    }\n  }\n\n  constructor(type, options, received) {\n    super(type)\n    this.name = 'LoguxError'\n    this.type = type\n    this.options = options\n    this.description = LoguxError.describe(type, options)\n    this.received = !!received\n\n    if (received) {\n      this.message = 'Logux received ' + this.type + ' error'\n      if (this.description !== this.type) {\n        this.message += ' (' + this.description + ')'\n      }\n    } else {\n      this.message = this.description\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, LoguxError)\n    }\n  }\n}\n","import { LoguxError } from '../logux-error/index.js'\n\nasync function auth(node, nodeId, token, callback) {\n  if (!node.options.auth) {\n    node.authenticated = true\n    callback()\n    return\n  }\n\n  try {\n    let access = await node.options.auth(nodeId, token, node.remoteHeaders)\n    if (access) {\n      node.authenticated = true\n      callback()\n      for (let i = 0; i < node.unauthenticated.length; i++) {\n        node.onMessage(node.unauthenticated[i])\n      }\n      node.unauthenticated = []\n    } else {\n      node.sendError(new LoguxError('wrong-credentials'))\n      node.destroy()\n    }\n  } catch (e) {\n    if (e.name === 'LoguxError') {\n      node.sendError(e)\n      node.destroy()\n    } else {\n      node.error(e)\n    }\n  }\n}\n\nfunction checkProtocol(node, ver) {\n  node.remoteProtocol = ver\n\n  if (ver >= node.minProtocol) {\n    return true\n  } else {\n    node.sendError(\n      new LoguxError('wrong-protocol', {\n        supported: node.minProtocol,\n        used: ver\n      })\n    )\n    node.destroy()\n    return false\n  }\n}\n\nfunction emitEvent(node) {\n  try {\n    node.emitter.emit('connect')\n  } catch (e) {\n    if (e.name === 'LoguxError') {\n      node.sendError(e)\n      return false\n    } else {\n      throw e\n    }\n  }\n  return true\n}\n\nexport async function sendConnect() {\n  let message = [\n    'connect',\n    this.localProtocol,\n    this.localNodeId,\n    this.lastReceived\n  ]\n\n  let options = {}\n  if (this.options.token) {\n    if (typeof this.options.token === 'function') {\n      options.token = await this.options.token()\n    } else {\n      options.token = this.options.token\n    }\n  }\n  if (this.options.subprotocol) {\n    options.subprotocol = this.options.subprotocol\n  }\n  if (Object.keys(options).length > 0) message.push(options)\n\n  if (this.options.fixTime) this.connectSended = this.now()\n\n  if (Object.keys(this.localHeaders).length > 0) {\n    this.sendHeaders(this.localHeaders)\n  }\n\n  this.startTimeout()\n  this.send(message)\n}\n\nexport async function sendConnected(start, end) {\n  let message = [\n    'connected',\n    this.localProtocol,\n    this.localNodeId,\n    [start, end]\n  ]\n\n  let options = {}\n  if (this.options.token) {\n    if (typeof this.options.token === 'function') {\n      options.token = await this.options.token()\n    } else {\n      options.token = this.options.token\n    }\n  }\n  if (this.options.subprotocol) {\n    options.subprotocol = this.options.subprotocol\n  }\n  if (Object.keys(options).length > 0) message.push(options)\n\n  if (Object.keys(this.localHeaders).length > 0) {\n    this.sendHeaders(this.localHeaders)\n  }\n\n  this.send(message)\n}\n\nexport function connectMessage(ver, nodeId, synced, options) {\n  let start = this.now()\n  if (!options) options = {}\n\n  this.remoteNodeId = nodeId\n  if (!checkProtocol(this, ver)) return\n\n  this.remoteSubprotocol = options.subprotocol || '0.0.0'\n\n  if (!emitEvent(this)) {\n    this.destroy()\n    return\n  }\n\n  auth(this, nodeId, options.token, () => {\n    this.baseTime = this.now()\n    this.sendConnected(start, this.baseTime)\n    this.syncSince(synced)\n  })\n}\n\nexport function connectedMessage(ver, nodeId, time, options) {\n  if (!options) options = {}\n\n  this.endTimeout()\n  this.remoteNodeId = nodeId\n  if (!checkProtocol(this, ver)) return\n\n  this.baseTime = time[1]\n\n  if (this.options.fixTime) {\n    let now = this.now()\n    let authTime = time[1] - time[0]\n    let roundTrip = now - this.connectSended - authTime\n    this.timeFix = Math.floor(this.connectSended - time[0] + roundTrip / 2)\n  }\n\n  this.remoteSubprotocol = options.subprotocol || '0.0.0'\n\n  if (!emitEvent(this)) {\n    this.destroy()\n    return\n  }\n\n  auth(this, nodeId, options.token, () => {\n    this.syncSince(this.lastSent)\n  })\n}\n","import { createNanoEvents } from 'nanoevents'\n\nimport {\n  sendConnect,\n  sendConnected,\n  connectMessage,\n  connectedMessage\n} from '../connect/index.js'\nimport {\n  syncedMessage,\n  syncMessage,\n  sendSynced,\n  sendSync\n} from '../sync/index.js'\nimport { sendPing, pingMessage, pongMessage } from '../ping/index.js'\nimport { sendHeaders, headersMessage } from '../headers/index.js'\nimport { sendDebug, debugMessage } from '../debug/index.js'\nimport { sendError, errorMessage } from '../error/index.js'\nimport { LoguxError } from '../logux-error/index.js'\n\nconst NOT_TO_THROW = {\n  'wrong-subprotocol': true,\n  'wrong-protocol': true,\n  'timeout': true\n}\n\nconst BEFORE_AUTH = ['connect', 'connected', 'error', 'debug', 'headers']\n\nasync function syncMappedEvent(node, action, meta) {\n  let added = meta.added\n  if (typeof added === 'undefined') {\n    let lastAdded = node.lastAddedCache\n    added = lastAdded > node.lastSent ? lastAdded : node.lastSent\n  }\n  if (node.options.outMap) {\n    try {\n      let changed = await node.options.outMap(action, meta)\n      node.sendSync(added, [changed])\n    } catch (e) {\n      node.error(e)\n    }\n  } else {\n    node.sendSync(added, [[action, meta]])\n  }\n}\n\nexport class BaseNode {\n  constructor(nodeId, log, connection, options = {}) {\n    this.remoteNodeId = undefined\n    this.remoteProtocol = undefined\n    this.remoteSubprotocol = undefined\n\n    this.minProtocol = 3\n    this.localProtocol = 4\n    this.localNodeId = nodeId\n\n    this.log = log\n    this.connection = connection\n    this.options = options\n\n    if (this.options.ping && !this.options.timeout) {\n      throw new Error('You must set timeout option to use ping')\n    }\n\n    this.connected = false\n    this.authenticated = false\n    this.unauthenticated = []\n\n    this.timeFix = 0\n    this.syncing = 0\n    this.received = {}\n\n    this.lastSent = 0\n    this.lastReceived = 0\n\n    this.state = 'disconnected'\n\n    this.emitter = createNanoEvents()\n    this.timeouts = []\n    this.throwsError = true\n\n    this.unbind = [\n      log.on('add', (action, meta) => {\n        this.onAdd(action, meta)\n      }),\n      connection.on('connecting', () => {\n        this.onConnecting()\n      }),\n      connection.on('connect', () => {\n        this.onConnect()\n      }),\n      connection.on('message', message => {\n        this.onMessage(message)\n      }),\n      connection.on('error', error => {\n        if (error.message === 'Wrong message format') {\n          this.sendError(new LoguxError('wrong-format', error.received))\n          this.connection.disconnect('error')\n        } else {\n          this.error(error)\n        }\n      }),\n      connection.on('disconnect', () => {\n        this.onDisconnect()\n      })\n    ]\n\n    this.initialized = false\n    this.lastAddedCache = 0\n    this.initializing = this.initialize()\n    this.localHeaders = {}\n    this.remoteHeaders = {}\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  catch(listener) {\n    this.throwsError = false\n    let unbind = this.on('error', listener)\n    return () => {\n      this.throwsError = true\n      unbind()\n    }\n  }\n\n  waitFor(state) {\n    if (this.state === state) {\n      return Promise.resolve()\n    }\n    return new Promise(resolve => {\n      let unbind = this.on('state', () => {\n        if (this.state === state) {\n          unbind()\n          resolve()\n        }\n      })\n    })\n  }\n\n  destroy() {\n    if (this.connection.destroy) {\n      this.connection.destroy()\n    } else if (this.connected) {\n      this.connection.disconnect('destroy')\n    }\n    for (let i of this.unbind) i()\n    clearTimeout(this.pingTimeout)\n    this.endTimeout()\n  }\n\n  setLocalHeaders(headers) {\n    this.localHeaders = headers\n    if (this.connected) {\n      this.sendHeaders(headers)\n    }\n  }\n\n  send(msg) {\n    if (!this.connected) return\n    this.delayPing()\n    try {\n      this.connection.send(msg)\n    } catch (e) {\n      this.error(e)\n    }\n  }\n\n  onConnecting() {\n    this.setState('connecting')\n  }\n\n  onConnect() {\n    this.delayPing()\n    this.connected = true\n  }\n\n  onDisconnect() {\n    while (this.timeouts.length > 0) {\n      this.endTimeout()\n    }\n    if (this.pingTimeout) clearTimeout(this.pingTimeout)\n    this.authenticated = false\n    this.connected = false\n    this.setState('disconnected')\n  }\n\n  onMessage(msg) {\n    this.delayPing()\n    let name = msg[0]\n\n    if (!this.authenticated && !BEFORE_AUTH.includes(name)) {\n      this.unauthenticated.push(msg)\n      return\n    }\n\n    this[name + 'Message'](...msg.slice(1))\n  }\n\n  async onAdd(action, meta) {\n    if (!this.authenticated) return\n    if (this.lastAddedCache < meta.added) {\n      this.lastAddedCache = meta.added\n    }\n\n    if (this.received && this.received[meta.id]) {\n      delete this.received[meta.id]\n      return\n    }\n\n    if (this.options.outFilter) {\n      try {\n        let result = await this.options.outFilter(action, meta)\n        if (result) syncMappedEvent(this, action, meta)\n      } catch (e) {\n        this.error(e)\n      }\n    } else {\n      syncMappedEvent(this, action, meta)\n    }\n  }\n\n  syncError(type, options, received) {\n    let err = new LoguxError(type, options, received)\n    this.emitter.emit('error', err)\n    if (!NOT_TO_THROW[type] && this.throwsError) {\n      throw err\n    }\n  }\n\n  error(err) {\n    this.emitter.emit('error', err)\n    this.connection.disconnect('error')\n    if (this.throwsError) {\n      throw err\n    }\n  }\n\n  setState(state) {\n    if (this.state !== state) {\n      this.state = state\n      this.emitter.emit('state')\n    }\n  }\n\n  startTimeout() {\n    if (!this.options.timeout) return\n\n    let ms = this.options.timeout\n    let timeout = setTimeout(() => {\n      if (this.connected) this.connection.disconnect('timeout')\n      this.syncError('timeout', ms)\n    }, ms)\n\n    this.timeouts.push(timeout)\n  }\n\n  endTimeout() {\n    if (this.timeouts.length > 0) {\n      clearTimeout(this.timeouts.shift())\n    }\n  }\n\n  delayPing() {\n    if (!this.options.ping) return\n    if (this.pingTimeout) clearTimeout(this.pingTimeout)\n\n    this.pingTimeout = setTimeout(() => {\n      if (this.connected && this.authenticated) this.sendPing()\n    }, this.options.ping)\n  }\n\n  async syncSinceQuery(lastSynced) {\n    let promises = []\n    await this.log.each({ order: 'added' }, (action, meta) => {\n      if (meta.added <= lastSynced) return false\n      if (this.options.outFilter) {\n        promises.push(\n          this.options\n            .outFilter(action, meta)\n            .then(r => {\n              if (r) {\n                return [action, meta]\n              } else {\n                return false\n              }\n            })\n            .catch(e => {\n              this.error(e)\n            })\n        )\n      } else {\n        promises.push(Promise.resolve([action, meta]))\n      }\n      return true\n    })\n\n    let entries = await Promise.all(promises)\n\n    let data = { added: 0 }\n    data.entries = entries.filter(entry => {\n      if (entry && data.added < entry[1].added) {\n        data.added = entry[1].added\n      }\n      return entry !== false\n    })\n    return data\n  }\n\n  async syncSince(lastSynced) {\n    let data = await this.syncSinceQuery(lastSynced)\n    if (!this.connected) return\n    if (data.entries.length > 0) {\n      if (this.options.outMap) {\n        Promise.all(\n          data.entries.map(i => {\n            return this.options.outMap(i[0], i[1])\n          })\n        )\n          .then(changed => {\n            this.sendSync(data.added, changed)\n          })\n          .catch(e => {\n            this.error(e)\n          })\n      } else {\n        this.sendSync(data.added, data.entries)\n      }\n    } else {\n      this.setState('synchronized')\n    }\n  }\n\n  setLastSent(value) {\n    if (this.lastSent < value) {\n      this.lastSent = value\n      this.log.store.setLastSynced({ sent: value })\n    }\n  }\n\n  setLastReceived(value) {\n    if (this.lastReceived < value) this.lastReceived = value\n    this.log.store.setLastSynced({ received: value })\n  }\n\n  now() {\n    return Date.now()\n  }\n\n  async initialize() {\n    let [synced, added] = await Promise.all([\n      this.log.store.getLastSynced(),\n      this.log.store.getLastAdded()\n    ])\n    this.initialized = true\n    this.lastSent = synced.sent\n    this.lastReceived = synced.received\n    this.lastAddedCache = added\n    if (this.connection.connected) this.onConnect()\n  }\n\n  sendDuilian() {\n    this.send(['duilian', Object.keys(DUILIANS)[0]])\n  }\n\n  duilianMessage(line) {\n    if (DUILIANS[line]) {\n      this.send(['duilian', DUILIANS[line]])\n    }\n  }\n}\n\nBaseNode.prototype.sendConnect = sendConnect\nBaseNode.prototype.sendConnected = sendConnected\nBaseNode.prototype.connectMessage = connectMessage\nBaseNode.prototype.connectedMessage = connectedMessage\n\nBaseNode.prototype.sendSync = sendSync\nBaseNode.prototype.sendSynced = sendSynced\nBaseNode.prototype.syncMessage = syncMessage\nBaseNode.prototype.syncedMessage = syncedMessage\n\nBaseNode.prototype.sendPing = sendPing\nBaseNode.prototype.pingMessage = pingMessage\nBaseNode.prototype.pongMessage = pongMessage\n\nBaseNode.prototype.sendDebug = sendDebug\nBaseNode.prototype.debugMessage = debugMessage\n\nBaseNode.prototype.sendError = sendError\nBaseNode.prototype.errorMessage = errorMessage\n\nBaseNode.prototype.sendHeaders = sendHeaders\nBaseNode.prototype.headersMessage = headersMessage\n\nconst DUILIANS = {\n  金木水火土: '板城烧锅酒'\n}\n","export function sendSync(added, entries) {\n  this.startTimeout()\n\n  let data = []\n  for (let [action, originMeta] of entries) {\n    let meta = {}\n    for (let key in originMeta) {\n      if (key === 'id') {\n        meta.id = originMeta.id.split(' ')\n      } else if (key !== 'added') {\n        meta[key] = originMeta[key]\n      }\n    }\n\n    if (this.timeFix) meta.time -= this.timeFix\n    meta.id[0] = parseInt(meta.id[0]) - this.baseTime\n    meta.id[2] = parseInt(meta.id[2])\n    meta.time -= this.baseTime\n\n    if (meta.id[1] === this.localNodeId) {\n      if (meta.id[2] === 0) {\n        meta.id = meta.id[0]\n      } else {\n        meta.id = [meta.id[0], meta.id[2]]\n      }\n    }\n\n    data.unshift(action, meta)\n  }\n\n  this.syncing += 1\n  this.setState('sending')\n  this.send(['sync', added].concat(data))\n}\n\nexport function sendSynced(added) {\n  this.send(['synced', added])\n}\n\nexport async function syncMessage(added, ...data) {\n  let promises = []\n\n  for (let i = 0; i < data.length - 1; i += 2) {\n    let action = data[i]\n    let meta = data[i + 1]\n\n    if (typeof meta.id === 'number') {\n      meta.id = meta.id + this.baseTime + ' ' + this.remoteNodeId + ' ' + 0\n    } else {\n      meta.id[0] = meta.id[0] + this.baseTime\n      if (meta.id.length === 2) {\n        meta.id = meta.id[0] + ' ' + this.remoteNodeId + ' ' + meta.id[1]\n      } else {\n        meta.id = meta.id.join(' ')\n      }\n    }\n\n    meta.time = meta.time + this.baseTime\n    if (this.timeFix) meta.time = meta.time + this.timeFix\n\n    let process = Promise.resolve([action, meta])\n\n    if (this.options.inMap) {\n      process = process\n        .then(([action2, meta2]) => {\n          return this.options.inMap(action2, meta2)\n        })\n        .catch(e => {\n          this.error(e)\n        })\n    }\n\n    process\n      .then(filtered => {\n        if (filtered && this.options.inFilter) {\n          return this.options\n            .inFilter(...filtered)\n            .then(res => {\n              return res ? filtered : false\n            })\n            .catch(e => {\n              this.error(e)\n            })\n        } else {\n          return filtered\n        }\n      })\n      .then(changed => {\n        if (!changed) return false\n        if (this.received) this.received[changed[1].id] = true\n        return this.log.add(changed[0], changed[1])\n      })\n\n    promises.push(process)\n  }\n\n  await Promise.all(promises)\n  this.setLastReceived(added)\n  this.sendSynced(added)\n}\n\nexport function syncedMessage(synced) {\n  this.endTimeout()\n  this.setLastSent(synced)\n  if (this.syncing > 0) this.syncing -= 1\n  if (this.syncing === 0) {\n    this.setState('synchronized')\n  }\n}\n","export function sendPing() {\n  this.startTimeout()\n  this.send(['ping', this.lastAddedCache])\n  if (this.pingTimeout) clearTimeout(this.pingTimeout)\n}\n\nexport function pingMessage(synced) {\n  this.setLastReceived(synced)\n  if (this.connected && this.authenticated) {\n    this.send(['pong', this.lastAddedCache])\n  }\n}\n\nexport function pongMessage(synced) {\n  this.setLastReceived(synced)\n  this.endTimeout()\n}\n","export function sendDebug(type, data) {\n  this.send(['debug', type, data])\n}\n\nexport function debugMessage(type, data) {\n  this.emitter.emit('debug', type, data)\n}\n","export function sendError(error) {\n  let message = ['error', error.type]\n  if (typeof error.options !== 'undefined') message.push(error.options)\n  this.send(message)\n\n  this.emitter.emit('clientError', error)\n}\n\nexport function errorMessage(type, options) {\n  this.syncError(type, options, true)\n}\n","export function sendHeaders(data) {\n  this.send(['headers', data])\n}\n\nexport function headersMessage(data) {\n  this.remoteHeaders = data\n  this.emitter.emit('headers', data)\n}\n","import { BaseNode } from '../base-node/index.js'\n\nconst DEFAULT_OPTIONS = {\n  fixTime: true,\n  timeout: 20000,\n  ping: 5000\n}\n\nexport class ClientNode extends BaseNode {\n  constructor(nodeId, log, connection, options = {}) {\n    options = { ...DEFAULT_OPTIONS, ...options }\n    super(nodeId, log, connection, options)\n  }\n\n  onConnect() {\n    if (!this.connected) {\n      this.connected = true\n      this.initializing = this.initializing.then(() => {\n        if (this.connected) this.sendConnect()\n      })\n    }\n  }\n}\n","import { createNanoEvents } from 'nanoevents'\n\nclass LocalConnection {\n  constructor(pair, type) {\n    this.connected = false\n    this.emitter = createNanoEvents()\n    this.type = type\n    this.pair = pair\n  }\n\n  other() {\n    if (this.type === 'left') {\n      return this.pair.right\n    } else {\n      return this.pair.left\n    }\n  }\n\n  on(event, listener) {\n    return this.emitter.on(event, listener)\n  }\n\n  connect() {\n    if (this.connected) {\n      throw new Error('Connection already established')\n    } else {\n      this.emitter.emit('connecting')\n      return new Promise(resolve => {\n        setTimeout(() => {\n          this.other().connected = true\n          this.connected = true\n          this.other().emitter.emit('connect')\n          this.emitter.emit('connect')\n          resolve()\n        }, this.pair.delay)\n      })\n    }\n  }\n\n  disconnect(reason) {\n    if (!this.connected) {\n      throw new Error('Connection already finished')\n    } else {\n      this.connected = false\n      this.emitter.emit('disconnect', reason)\n      return new Promise(resolve => {\n        setTimeout(() => {\n          this.other().connected = false\n          this.other().emitter.emit('disconnect')\n          resolve()\n        }, 1)\n      })\n    }\n  }\n\n  send(message) {\n    if (this.connected) {\n      setTimeout(() => {\n        this.other().emitter.emit('message', message)\n      }, this.pair.delay)\n    } else {\n      throw new Error('Connection should be started before sending a message')\n    }\n  }\n}\n\nexport class LocalPair {\n  constructor(delay = 1) {\n    this.delay = delay\n    this.left = new LocalConnection(this, 'left')\n    this.right = new LocalConnection(this, 'right')\n  }\n}\n","const DEFAULT_OPTIONS = {\n  minDelay: 1000,\n  maxDelay: 5000,\n  attempts: Infinity\n}\n\nconst FATAL_ERRORS = [\n  'wrong-protocol',\n  'wrong-subprotocol',\n  'wrong-credentials'\n]\n\nexport class Reconnect {\n  constructor(connection, options = {}) {\n    this.connection = connection\n    this.options = { ...DEFAULT_OPTIONS, ...options }\n\n    this.reconnecting = connection.connected\n    this.connecting = false\n    this.attempts = 0\n\n    this.unbind = [\n      this.connection.on('message', msg => {\n        if (msg[0] === 'error' && FATAL_ERRORS.includes(msg[1])) {\n          this.reconnecting = false\n        }\n      }),\n      this.connection.on('connecting', () => {\n        this.connecting = true\n      }),\n      this.connection.on('connect', () => {\n        this.attempts = 0\n        this.connecting = false\n      }),\n      this.connection.on('disconnect', () => {\n        this.connecting = false\n        if (this.reconnecting) this.reconnect()\n      }),\n      () => {\n        clearTimeout(this.timer)\n      }\n    ]\n\n    let visibility = () => {\n      if (this.reconnecting && !this.connected && !this.connecting) {\n        if (typeof document !== 'undefined' && !document.hidden) this.connect()\n      }\n    }\n    let connect = () => {\n      if (this.reconnecting && !this.connected && !this.connecting) {\n        if (navigator.onLine) this.connect()\n      }\n    }\n    let disconnect = () => {\n      this.disconnect('freeze')\n    }\n    if (\n      typeof document !== 'undefined' &&\n      typeof window !== 'undefined' &&\n      document.addEventListener &&\n      window.addEventListener\n    ) {\n      document.addEventListener('visibilitychange', visibility, false)\n      window.addEventListener('focus', connect, false)\n      window.addEventListener('online', connect, false)\n      window.addEventListener('resume', connect, false)\n      window.addEventListener('freeze', disconnect, false)\n      this.unbind.push(() => {\n        document.removeEventListener('visibilitychange', visibility, false)\n        window.removeEventListener('focus', connect, false)\n        window.removeEventListener('online', connect, false)\n        window.removeEventListener('resume', connect, false)\n        window.removeEventListener('freeze', disconnect, false)\n      })\n    }\n  }\n\n  connect() {\n    this.attempts += 1\n    this.reconnecting = true\n    return this.connection.connect()\n  }\n\n  disconnect(reason) {\n    if (reason !== 'timeout' && reason !== 'error' && reason !== 'freeze') {\n      this.reconnecting = false\n    }\n    return this.connection.disconnect(reason)\n  }\n\n  destroy() {\n    for (let i of this.unbind) i()\n    this.disconnect('destroy')\n  }\n\n  reconnect() {\n    if (this.attempts > this.options.attempts - 1) {\n      this.reconnecting = false\n      this.attempts = 0\n      return\n    }\n\n    let delay = this.nextDelay()\n    this.timer = setTimeout(() => {\n      if (this.reconnecting && !this.connecting && !this.connected) {\n        this.connect()\n      }\n    }, delay)\n  }\n\n  send(...args) {\n    return this.connection.send(...args)\n  }\n\n  on(...args) {\n    return this.connection.on(...args)\n  }\n\n  nextDelay() {\n    let base = this.options.minDelay * 2 ** this.attempts\n    let rand = Math.random()\n    let deviation = Math.floor(rand * 0.5 * base)\n    if (Math.floor(rand * 10) === 1) deviation = -deviation\n    return Math.min(base + deviation, this.options.maxDelay) || 0\n  }\n\n  get connected() {\n    return this.connection.connected\n  }\n\n  get emitter() {\n    return this.connection.emitter\n  }\n}\n","export function parseId(nodeId) {\n  if (nodeId.includes(' ')) nodeId = nodeId.split(' ')[1]\n  let parts = nodeId.split(':')\n  if (parts.length === 1) {\n    return { nodeId, userId: undefined, clientId: nodeId }\n  } else {\n    let userId = parts[0]\n    return { nodeId, userId, clientId: parts[0] + ':' + parts[1] }\n  }\n}\n","export function status(client, callback, options = {}) {\n  let observable = client.on ? client : client.node\n  let disconnected = observable.state === 'disconnected'\n  let wait = false\n  let old = false\n\n  if (typeof options.duration === 'undefined') options.duration = 3000\n\n  let timeout\n  let unbind = []\n  let processing = {}\n\n  function setSynchronized() {\n    if (Object.keys(processing).length === 0) {\n      if (wait) {\n        wait = false\n        callback('synchronizedAfterWait')\n        timeout = setTimeout(() => {\n          callback('synchronized')\n        }, options.duration)\n      } else {\n        callback('synchronized')\n      }\n    }\n  }\n\n  function changeState() {\n    clearTimeout(timeout)\n\n    if (old) return\n    if (observable.state === 'disconnected') {\n      disconnected = true\n      callback(wait ? 'wait' : 'disconnected')\n    } else if (observable.state === 'synchronized') {\n      disconnected = false\n      setSynchronized()\n    } else if (observable.state === 'connecting') {\n      timeout = setTimeout(() => {\n        callback('connecting' + (wait ? 'AfterWait' : ''))\n      }, 100)\n    } else {\n      callback(client.state + (wait ? 'AfterWait' : ''))\n    }\n  }\n\n  unbind.push(observable.on('state', changeState))\n\n  unbind.push(\n    client.node.on('error', error => {\n      if (\n        error.type === 'wrong-protocol' ||\n        error.type === 'wrong-subprotocol'\n      ) {\n        old = true\n        callback('protocolError')\n      } else if (error.type !== 'timeout') {\n        callback('syncError', { error })\n      }\n    })\n  )\n\n  unbind.push(\n    client.node.on('clientError', error => {\n      callback('syncError', { error })\n    })\n  )\n\n  let log = client.on ? client : client.log\n  unbind.push(\n    log.on('add', (action, meta) => {\n      if (action.type === 'logux/subscribe') {\n        return\n      } else if (action.type === 'logux/unsubscribe') {\n        return\n      }\n\n      if (action.type === 'logux/processed') {\n        delete processing[action.id]\n        setSynchronized()\n      } else if (action.type === 'logux/undo') {\n        delete processing[action.id]\n      } else if (meta.sync) {\n        processing[meta.id] = true\n      }\n\n      if (action.type === 'logux/undo' && action.reason) {\n        if (action.reason === 'denied') {\n          callback('denied', { action, meta })\n        } else {\n          callback('error', { action, meta })\n        }\n      } else if (disconnected && meta.sync && meta.added) {\n        if (!wait) callback('wait')\n        wait = true\n      }\n    })\n  )\n\n  changeState()\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","import { status } from '../status/index.js'\n\nfunction injectStyles(element, styles) {\n  for (let i in styles) {\n    element.style[i] = styles[i]\n  }\n}\n\nfunction setPosition(element, position) {\n  let style = element.style\n  if (position === 'middle-center' || position === 'center-middle') {\n    style.top = '50%'\n    style.left = '50%'\n    style.transform = 'translate(-50%, -50%)'\n  } else {\n    position.split('-').forEach(pos => {\n      if (pos === 'middle') {\n        style.top = '50%'\n        style.transform = 'translateY(-50%)'\n      } else if (pos === 'center') {\n        style.left = '50%'\n        style.transform = 'translateX(-50%)'\n      } else {\n        style[pos] = '0'\n      }\n    })\n  }\n}\n\nconst RESET = {\n  boxSizing: 'content-box',\n  visibility: 'visible',\n  textIndent: '0',\n  textTransform: 'none',\n  wordSpacing: 'normal',\n  letterSpacing: 'normal',\n  fontStyle: 'normal',\n  fontVariant: 'normal',\n  fontWeight: 'normal',\n  lineHeight: 'auto'\n}\n\nexport function badge(client, opts) {\n  let messages = opts.messages\n  let position = opts.position || 'bottom-right'\n  let styles = opts.styles\n\n  let widget = document.createElement('div')\n  let text = document.createElement('span')\n\n  widget.setAttribute('role', 'alert')\n\n  injectStyles(widget, RESET)\n  injectStyles(widget, styles.base)\n  injectStyles(text, styles.text)\n  setPosition(widget, position)\n\n  let show = (style, msg) => {\n    text.innerHTML = msg\n    injectStyles(widget, style)\n    widget.style.display = 'block'\n  }\n\n  let hide = () => {\n    widget.style.display = 'none'\n  }\n\n  let unbind = status(\n    client,\n    state => {\n      if (state === 'sendingAfterWait' || state === 'connectingAfterWait') {\n        show(styles.sending, messages.sending)\n      } else if (state === 'synchronizedAfterWait') {\n        show(styles.synchronized, messages.synchronized)\n      } else if (state === 'synchronized') {\n        hide(widget)\n      } else if (state === 'disconnected') {\n        show(styles.disconnected, messages.disconnected)\n      } else if (state === 'wait') {\n        show(styles.wait, messages.wait)\n      } else if (state === 'protocolError') {\n        show(styles.protocolError, messages.protocolError)\n      } else if (state === 'syncError') {\n        show(styles.error, messages.syncError)\n      } else if (state === 'error') {\n        show(styles.error, messages.error)\n      } else if (state === 'denied') {\n        show(styles.error, messages.denied)\n      }\n    },\n    opts\n  )\n\n  widget.appendChild(text)\n  document.body.appendChild(widget)\n\n  return () => {\n    unbind()\n    document.body.removeChild(widget)\n  }\n}\n\nexport let badgeRu = {\n  synchronized: 'Ваши данные сохранены',\n  disconnected: 'Нет интернета',\n  wait: 'Нет интернета<br>Ваши данные не сохранены',\n  sending: 'Сохраняю ваши данные',\n  syncError: 'Ошибка на сервере<br>Ваши данные не сохранены',\n  error: 'Ошибка на сервере<br>Ваши действия отменены',\n  denied: 'Нет прав<br>Ваши действия отменены',\n  protocolError: 'Сохранение не работает<br>Обновите страницу'\n}\n\nexport let badgeEn = {\n  synchronized: 'Your data has been saved',\n  disconnected: 'No Internet connection',\n  wait: 'No Internet connection<br>Your data has not been saved',\n  sending: 'Data saving',\n  syncError: 'Server error<br>Your data has not been saved',\n  error: 'Server error<br>You changes was reverted',\n  denied: 'You have no access<br>You changes was reverted',\n  protocolError: 'Saving is not working<br>Refresh the page'\n}\n","// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nimport { urlAlphabet } from './url-alphabet/index.js'\n\nif (process.env.NODE_ENV !== 'production') {\n  // All bundlers will remove this block in the production bundle.\n  if (\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative' &&\n    typeof crypto === 'undefined'\n  ) {\n    throw new Error(\n      'React Native does not have a built-in secure random generator. ' +\n        'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' +\n        'For secure IDs, import `react-native-get-random-values` ' +\n        'before Nano ID.'\n    )\n  }\n  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {\n    throw new Error(\n      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +\n        ' before importing Nano ID to fix IE 11 support'\n    )\n  }\n  if (typeof crypto === 'undefined') {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n        'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\n\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\n\nlet customRandom = (alphabet, size, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  // `Math.clz32` is not used, because it is not available in browsers.\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n\n  // `-~f => Math.ceil(f)` if f is a float\n  // `-~i => i + 1` if i is an integer\n  let step = -~((1.6 * mask * size) / alphabet.length)\n\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\n      let j = step\n      while (j--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\n  while (size--) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\n\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","export class LoguxUndoError extends Error {\n  constructor(action) {\n    let type = action.action ? action.action.type : 'action'\n    super(`Server undid ${type} because of ${action.reason}`)\n    this.name = 'LoguxUndoError'\n    this.action = action\n  }\n}\n","import { createNanoEvents } from 'nanoevents'\nimport {\n  isFirstOlder,\n  WsConnection,\n  MemoryStore,\n  ClientNode,\n  Reconnect,\n  parseId,\n  Log\n} from '@logux/core'\nimport { nanoid } from 'nanoid'\n\nimport { LoguxUndoError } from '../logux-undo-error/index.js'\nimport { track } from '../track/index.js'\n\nlet ALLOWED_META = ['id', 'time', 'subprotocol']\n\nfunction tabPing(c) {\n  localStorage.setItem(c.options.prefix + ':tab:' + c.tabId, Date.now())\n}\n\nfunction cleanTabActions(client, id) {\n  client.log.removeReason('tab' + id).then(() => {\n    if (client.isLocalStorage) {\n      localStorage.removeItem(client.options.prefix + ':tab:' + id)\n    }\n  })\n}\n\nexport class Client {\n  constructor(opts = {}) {\n    this.options = opts\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof this.options.server === 'undefined') {\n        throw new Error('Missed server option in Logux client')\n      }\n      if (typeof this.options.subprotocol === 'undefined') {\n        throw new Error('Missed subprotocol option in Logux client')\n      }\n      if (typeof this.options.userId === 'undefined') {\n        throw new Error(\n          'Missed userId option in Logux client. ' +\n            'Pass false if you have no users.'\n        )\n      }\n      if (this.options.userId === false) {\n        throw new Error('Replace userId: false to userId: \"false\"')\n      }\n      if (typeof this.options.userId !== 'string') {\n        throw new Error('userId must be a string')\n      }\n      if (this.options.userId.includes(':')) {\n        throw new Error('userId can’t contain colon character')\n      }\n    }\n\n    if (typeof this.options.prefix === 'undefined') {\n      this.options.prefix = 'logux'\n    }\n\n    this.isLocalStorage = false\n    if (typeof localStorage !== 'undefined') {\n      let random = nanoid()\n      try {\n        localStorage.setItem(random, '1')\n        localStorage.removeItem(random)\n        this.isLocalStorage = true\n      } catch {}\n    }\n\n    if (!this.options.time) {\n      this.clientId = this.options.userId + ':' + this.getClientId()\n      this.tabId = nanoid(8)\n    } else {\n      this.tabId = this.options.time.lastId + 1 + ''\n      this.clientId = this.options.userId + ':' + this.tabId\n    }\n\n    this.nodeId = this.clientId + ':' + this.tabId\n    let store = this.options.store || new MemoryStore()\n\n    let log\n    if (this.options.time) {\n      log = this.options.time.nextLog({ store, nodeId: this.nodeId })\n    } else {\n      log = new Log({ store, nodeId: this.nodeId })\n    }\n    this.log = log\n\n    log.on('preadd', (action, meta) => {\n      if (parseId(meta.id).nodeId === this.nodeId && !meta.subprotocol) {\n        meta.subprotocol = this.options.subprotocol\n      }\n      if (meta.sync && !meta.resubscribe) meta.reasons.push('syncing')\n    })\n\n    this.last = {}\n    this.subscriptions = {}\n    let subscribing = {}\n    let unsubscribing = {}\n\n    this.emitter = createNanoEvents()\n    this.on('add', (action, meta) => {\n      let type = action.type\n      let json, last\n      if (type === 'logux/processed' || type === 'logux/undo') {\n        this.log.removeReason('syncing', { id: action.id })\n      }\n      if (type === 'logux/subscribe' && !meta.resubscribe) {\n        subscribing[meta.id] = action\n      } else if (type === 'logux/unsubscribe') {\n        unsubscribing[meta.id] = action\n      } else if (type === 'logux/processed') {\n        if (unsubscribing[action.id]) {\n          let unsubscription = unsubscribing[action.id]\n          json = JSON.stringify({ ...unsubscription, type: 'logux/subscribe' })\n          let subscribers = this.subscriptions[json]\n          if (subscribers) {\n            if (subscribers === 1) {\n              delete this.subscriptions[json]\n            } else {\n              this.subscriptions[json] = subscribers - 1\n            }\n          }\n        }\n        if (subscribing[action.id]) {\n          let subscription = subscribing[action.id]\n          delete subscribing[action.id]\n          json = JSON.stringify(subscription)\n          if (this.subscriptions[json]) {\n            this.subscriptions[json] += 1\n          } else {\n            this.subscriptions[json] = 1\n          }\n          last = this.last[subscription.channel]\n          if (!last || isFirstOlder(last, meta)) {\n            this.last[subscription.channel] = { id: meta.id, time: meta.time }\n          }\n        }\n        if (type === 'logux/processed' && this.processing[action.id]) {\n          this.processing[action.id][1](meta)\n          delete this.processing[action.id]\n        }\n      } else if (type === 'logux/undo') {\n        if (this.processing[action.id]) {\n          this.processing[action.id][2](new LoguxUndoError(action))\n          delete this.processing[action.id]\n        }\n        delete subscribing[action.id]\n        delete unsubscribing[action.id]\n      } else if (meta.channels) {\n        if (!meta.id.includes(' ' + this.clientId + ':')) {\n          meta.channels.forEach(channel => {\n            last = this.last[channel]\n            if (!last || isFirstOlder(last, meta)) {\n              this.last[channel] = { id: meta.id, time: meta.time }\n            }\n          })\n        }\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        if (type === 'logux/subscribe' || type === 'logux/unsubscribe') {\n          if (!meta.sync) {\n            console.error(type + ' action without meta.sync')\n          }\n        }\n      }\n    })\n\n    this.tabPing = 60000\n    this.tabTimeout = 10 * this.tabPing\n    let reason = 'tab' + this.tabId\n    if (this.isLocalStorage) {\n      let unbind = log.on('add', (action, meta) => {\n        if (meta.reasons.includes(reason)) {\n          tabPing(this)\n          this.pinging = setInterval(() => {\n            tabPing(this)\n          }, this.tabPing)\n          unbind()\n        }\n      })\n    }\n\n    let connection\n    if (typeof this.options.server === 'string') {\n      let ws = new WsConnection(this.options.server)\n      connection = new Reconnect(ws, {\n        minDelay: this.options.minDelay,\n        maxDelay: this.options.maxDelay,\n        attempts: this.options.attempts\n      })\n    } else {\n      connection = this.options.server\n    }\n\n    let outFilter = async (action, meta) => {\n      return !!meta.sync && parseId(meta.id).userId === this.options.userId\n    }\n\n    let outMap = async (action, meta) => {\n      let filtered = {}\n      for (let i in meta) {\n        if (i === 'subprotocol') {\n          if (meta.subprotocol !== this.options.subprotocol) {\n            filtered.subprotocol = meta.subprotocol\n          }\n        } else if (ALLOWED_META.includes(i)) {\n          filtered[i] = meta[i]\n        }\n      }\n      return [action, filtered]\n    }\n\n    if (!this.options.time) {\n      if (typeof this.options.timeout === 'undefined') {\n        this.options.timeout = 20000\n      }\n      if (typeof this.options.ping === 'undefined') {\n        this.options.ping = 5000\n      }\n    }\n\n    this.node = new ClientNode(this.nodeId, this.log, connection, {\n      subprotocol: this.options.subprotocol,\n      outFilter,\n      timeout: this.options.timeout,\n      fixTime: !this.options.time,\n      outMap,\n      token: this.options.token,\n      ping: this.options.ping\n    })\n\n    if (/^ws:\\/\\//.test(this.options.server) && !opts.allowDangerousProtocol) {\n      let unbindEnvTest = this.node.on('state', () => {\n        if (this.node.state === 'synchronized') {\n          unbindEnvTest()\n          if (this.node.remoteHeaders.env !== 'development') {\n            console.error(\n              'Without SSL, old proxies block WebSockets. ' +\n                'Use WSS for Logux or set allowDangerousProtocol option.'\n            )\n            this.destroy()\n          }\n        }\n      })\n    }\n\n    this.node.on('debug', (type, stack) => {\n      if (type === 'error') {\n        console.error('Error on Logux server:\\n', stack)\n      }\n    })\n\n    let disconnected = true\n    this.node.on('state', () => {\n      let state = this.node.state\n      if (state === 'synchronized' || state === 'sending') {\n        if (disconnected) {\n          disconnected = false\n          for (let i in this.subscriptions) {\n            let action = JSON.parse(i)\n            let since = this.last[action.channel]\n            if (since) action.since = since\n            this.log.add(action, { sync: true, resubscribe: true })\n          }\n        }\n      } else if (this.node.state === 'disconnected') {\n        disconnected = true\n      }\n    })\n\n    this.onUnload = this.onUnload.bind(this)\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('unload', this.onUnload)\n    }\n\n    this.processing = {}\n  }\n\n  get state() {\n    return this.node.state\n  }\n\n  get connected() {\n    return this.state !== 'disconnected' && this.state !== 'connecting'\n  }\n\n  start() {\n    this.cleanPrevActions()\n    this.node.connection.connect()\n  }\n\n  sync(action, meta = {}) {\n    meta.sync = true\n    if (typeof meta.id === 'undefined') {\n      meta.id = this.log.generateId()\n    }\n\n    this.log.add(action, meta)\n    return track(this, meta.id)\n  }\n\n  type(type, listener, opts) {\n    return this.log.type(type, listener, opts)\n  }\n\n  on(event, listener) {\n    if (event === 'state') {\n      return this.node.emitter.on(event, listener)\n    } else if (event === 'user') {\n      return this.emitter.on(event, listener)\n    } else {\n      return this.log.emitter.on(event, listener)\n    }\n  }\n\n  changeUser(userId, token) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof userId !== 'string') {\n        throw new Error('userId must be a string')\n      }\n      if (userId.includes(':')) {\n        throw new Error('userId can’t contain colon character')\n      }\n    }\n\n    let wasConnected = this.node.connected\n    if (wasConnected) this.node.connection.disconnect('destroy')\n\n    this.options.userId = userId\n    this.options.token = token\n    this.clientId = userId + ':' + this.getClientId()\n    this.nodeId = this.clientId + ':' + this.tabId\n\n    this.log.nodeId = this.nodeId\n    this.node.localNodeId = this.nodeId\n    this.node.options.token = token\n\n    this.emitter.emit('user', userId)\n    if (wasConnected) this.node.connection.connect()\n  }\n\n  waitFor(state) {\n    if (this.state === state) {\n      return Promise.resolve()\n    }\n    return new Promise(resolve => {\n      let unbind = this.on('state', () => {\n        if (this.state === state) {\n          unbind()\n          resolve()\n        }\n      })\n    })\n  }\n\n  destroy() {\n    this.onUnload()\n    this.node.destroy()\n    clearInterval(this.pinging)\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('unload', this.onUnload)\n    }\n  }\n\n  clean() {\n    this.destroy()\n    return this.log.store.clean ? this.log.store.clean() : Promise.resolve()\n  }\n\n  cleanPrevActions() {\n    if (!this.isLocalStorage) return\n\n    for (let i in localStorage) {\n      let prefix = this.options.prefix + ':tab:'\n      if (i.slice(0, prefix.length) === prefix) {\n        let time = parseInt(localStorage.getItem(i))\n        if (Date.now() - time > this.tabTimeout) {\n          cleanTabActions(this, i.slice(prefix.length))\n        }\n      }\n    }\n  }\n\n  onUnload() {\n    if (this.pinging) cleanTabActions(this, this.tabId)\n  }\n\n  getClientId() {\n    return nanoid(8)\n  }\n}\n","import { LoguxError, actionEvents } from '@logux/core'\n\nimport { Client } from '../client/index.js'\n\nfunction storageKey(client, name) {\n  return client.options.prefix + ':' + client.options.userId + ':' + name\n}\n\nfunction sendToTabs(client, event, data) {\n  if (!client.isLocalStorage) return\n  let key = storageKey(client, event)\n  let json = JSON.stringify(data)\n  try {\n    localStorage.setItem(key, json)\n  } catch (e) {\n    console.error(e)\n    client.isLocalStorage = false\n    client.role = 'leader'\n    client.emitter.emit('role')\n    client.node.connection.connect()\n  }\n}\n\nfunction getLeader(client) {\n  let data = localStorage.getItem(storageKey(client, 'leader'))\n  let json = []\n  if (typeof data === 'string') json = JSON.parse(data)\n  return json\n}\n\nfunction leaderPing(client) {\n  sendToTabs(client, 'leader', [client.tabId, Date.now()])\n}\n\nfunction onDeadLeader(client) {\n  if (client.state !== 'disconnected') {\n    setState(client, 'disconnected')\n  }\n  startElection(client)\n}\n\nfunction watchForLeader(client) {\n  clearTimeout(client.watching)\n  client.watching = setTimeout(() => {\n    if (!isActiveLeader(client)) {\n      onDeadLeader(client)\n    } else {\n      watchForLeader(client)\n    }\n  }, client.roleTimeout)\n}\n\nfunction compareSubprotocols(left, right) {\n  let leftParts = left.split('.')\n  let rightParts = right.split('.')\n  for (let i = 0; i < 3; i++) {\n    let leftNumber = parseInt(leftParts[i] || 0)\n    let rightNumber = parseInt(rightParts[i] || 0)\n    if (leftNumber > rightNumber) {\n      return 1\n    } else if (leftNumber < rightNumber) {\n      return -1\n    }\n  }\n  return 0\n}\n\nfunction setRole(client, role) {\n  if (client.role !== role) {\n    let node = client.node\n    client.role = role\n\n    clearTimeout(client.watching)\n    if (role === 'leader') {\n      localStorage.removeItem(storageKey(client, 'state'))\n      client.leadership = setInterval(() => {\n        if (!client.unloading) leaderPing(client)\n      }, client.leaderPing)\n      node.connection.connect()\n    } else {\n      clearTimeout(client.elections)\n      clearInterval(client.leadership)\n\n      if (node.state !== 'disconnected') {\n        client.node.connection.disconnect()\n      }\n    }\n\n    if (role === 'follower') {\n      let state = 'disconnected'\n      let json = localStorage.getItem(storageKey(client, 'state'))\n      if (json && json !== null) state = JSON.parse(json)\n      if (state !== client.state) {\n        client.state = state\n        client.emitter.emit('state')\n      }\n    }\n\n    client.emitter.emit('role')\n  }\n}\n\nfunction isActiveLeader(client) {\n  let leader = getLeader(client)\n  return leader[1] && leader[1] >= Date.now() - client.leaderTimeout\n}\n\nfunction startElection(client) {\n  leaderPing(client)\n  setRole(client, 'candidate')\n  client.elections = setTimeout(() => {\n    let data = getLeader(client, 'leader')\n    if (data[0] === client.tabId) {\n      setRole(client, 'leader')\n    } else {\n      setRole(client, 'follower')\n      watchForLeader(client)\n    }\n  }, client.electionDelay)\n}\n\nfunction setState(client, state) {\n  client.state = state\n  client.emitter.emit('state')\n  sendToTabs(client, 'state', client.state)\n}\n\nfunction isMemory(store) {\n  return Array.isArray(store.entries) && Array.isArray(store.added)\n}\n\nexport class CrossTabClient extends Client {\n  constructor(opts = {}) {\n    super(opts)\n\n    this.role = 'candidate'\n\n    this.roleTimeout = 3000 + Math.floor(Math.random() * 1000)\n    this.leaderTimeout = 5000\n    this.leaderPing = 2000\n    this.electionDelay = 1000\n\n    this.leaderState = this.node.state\n\n    this.node.on('state', () => {\n      if (this.role === 'leader') {\n        setState(this, this.node.state)\n      }\n    })\n\n    this.log.on('add', (action, meta) => {\n      actionEvents(this.emitter, 'add', action, meta)\n      if (meta.tab !== this.tabId) {\n        sendToTabs(this, 'add', [this.tabId, action, meta])\n      }\n    })\n    this.log.on('clean', (action, meta) => {\n      actionEvents(this.emitter, 'clean', action, meta)\n    })\n\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('storage', e => this.onStorage(e))\n      window.addEventListener('unload', e => this.onUnload(e))\n    }\n\n    if (this.isLocalStorage) {\n      let subprotocolKey = storageKey(this, 'subprotocol')\n      if (localStorage.getItem(subprotocolKey) !== this.options.subprotocol) {\n        sendToTabs(this, 'subprotocol', this.options.subprotocol)\n      }\n    }\n  }\n\n  get state() {\n    return this.leaderState\n  }\n\n  set state(value) {\n    this.leaderState = value\n  }\n\n  start() {\n    this.cleanPrevActions()\n\n    if (!this.isLocalStorage) {\n      this.role = 'leader'\n      this.emitter.emit('role')\n      this.node.connection.connect()\n      return\n    }\n\n    if (isActiveLeader(this)) {\n      setRole(this, 'follower')\n      watchForLeader(this)\n    } else {\n      startElection(this)\n    }\n  }\n\n  destroy() {\n    super.destroy()\n\n    clearTimeout(this.watching)\n    clearTimeout(this.elections)\n    clearInterval(this.leadership)\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('storage', this.onStorage)\n    }\n  }\n\n  clean() {\n    if (this.isLocalStorage) {\n      localStorage.removeItem(storageKey(this, 'add'))\n      localStorage.removeItem(storageKey(this, 'state'))\n      localStorage.removeItem(storageKey(this, 'client'))\n      localStorage.removeItem(storageKey(this, 'leader'))\n    }\n    return super.clean()\n  }\n\n  changeUser(userId, token) {\n    sendToTabs(this, 'user', [this.tabId, userId])\n    super.changeUser(userId, token)\n  }\n\n  type(type, listener, opts = {}) {\n    if (opts.event === 'preadd') {\n      return this.log.type(type, listener, opts)\n    } else {\n      let event = opts.event || 'add'\n      let id = opts.id || ''\n      return this.emitter.on(`${event}-${type}-${id}`, listener)\n    }\n  }\n\n  on(event, listener) {\n    if (event === 'preadd') {\n      return this.log.emitter.on(event, listener)\n    } else {\n      return this.emitter.on(event, listener)\n    }\n  }\n\n  onStorage(e) {\n    if (e.newValue === null) return\n\n    let data\n    if (e.key === storageKey(this, 'add')) {\n      data = JSON.parse(e.newValue)\n      if (data[0] !== this.tabId) {\n        let action = data[1]\n        let meta = data[2]\n        if (!meta.tab || meta.tab === this.tabId) {\n          if (isMemory(this.log.store)) {\n            this.log.store.add(action, meta)\n          }\n          actionEvents(this.emitter, 'add', action, meta)\n          if (this.role === 'leader') {\n            this.node.onAdd(action, meta)\n          }\n        }\n      }\n    } else if (e.key === storageKey(this, 'leader')) {\n      data = JSON.parse(e.newValue)\n      if (data.length === 0) {\n        onDeadLeader(this)\n      } else if (data[0] !== this.tabId && this.role !== 'candidate') {\n        setRole(this, 'follower')\n        watchForLeader(this)\n      }\n    } else if (e.key === storageKey(this, 'state')) {\n      let state = JSON.parse(localStorage.getItem(e.key))\n      if (this.leaderState !== state) {\n        this.leaderState = state\n        this.emitter.emit('state')\n      }\n    } else if (e.key === storageKey(this, 'user')) {\n      data = JSON.parse(e.newValue)\n      if (data[0] !== this.tabId) {\n        this.emitter.emit('user', data[1])\n      }\n    } else if (e.key === storageKey(this, 'subprotocol')) {\n      let other = JSON.parse(e.newValue)\n      let compare = compareSubprotocols(this.options.subprotocol, other)\n      if (compare === 1) {\n        sendToTabs(this, 'subprotocol', this.options.subprotocol)\n      } else if (compare === -1) {\n        let err = new LoguxError(\n          'wrong-subprotocol',\n          { supported: other, used: this.options.subprotocol },\n          true\n        )\n        this.node.emitter.emit('error', err)\n      }\n    }\n  }\n\n  onUnload() {\n    if (this.role === 'leader') {\n      this.unloading = true\n      sendToTabs(this, 'leader', [])\n    }\n    super.onUnload()\n  }\n\n  getClientId() {\n    let key = storageKey(this, 'client')\n    if (!this.isLocalStorage) {\n      return super.getClientId()\n    } else if (localStorage.getItem(key)) {\n      return localStorage.getItem(key)\n    } else {\n      let clientId = super.getClientId()\n      localStorage.setItem(key, clientId)\n      return clientId\n    }\n  }\n}\n","function block(e) {\n  e.returnValue = 'unsynced'\n  return 'unsynced'\n}\n\nexport function confirm(client) {\n  let disconnected = client.state === 'disconnected'\n  let wait = false\n\n  let update = () => {\n    if (client.state === 'disconnected') {\n      disconnected = true\n    } else if (client.state === 'synchronized') {\n      disconnected = false\n      wait = false\n    }\n\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      if (client.role !== 'follower' && wait && disconnected) {\n        window.addEventListener('beforeunload', block)\n      } else {\n        window.removeEventListener('beforeunload', block)\n      }\n    }\n  }\n\n  let unbind = []\n  unbind.push(client.on('role', update))\n  unbind.push(client.on('state', update))\n  update()\n\n  unbind.push(\n    client.on('add', (action, meta) => {\n      if (action.type === 'logux/subscribe') {\n        return\n      } else if (action.type === 'logux/unsubscribe') {\n        return\n      }\n      if (disconnected && meta.sync && meta.added) {\n        wait = true\n        update()\n      }\n    })\n  )\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","import { parseId } from '@logux/core'\n\nfunction bold(string) {\n  return '%c' + string + '%c'\n}\n\nfunction showLog(text, details) {\n  text = '%cLogux%c ' + text\n  let args = Array.from(text.match(/%c/g)).map((_, i) => {\n    if (i === 0) {\n      return 'color:#ffa200;font-weight:bold'\n    } else if (i % 2 === 0) {\n      return 'font-weight:bold'\n    } else {\n      return 'font-weight:normal'\n    }\n  })\n\n  if (details) {\n    console.groupCollapsed(text, ...args)\n    for (let name in details) {\n      if (typeof details[name] === 'string') {\n        console.log(name + ': %c' + details[name], 'font-weight:bold')\n      } else {\n        console.log(name, details[name])\n      }\n    }\n    console.groupEnd()\n  } else {\n    console.log(text, ...args)\n  }\n}\n\nexport function log(client, messages = {}) {\n  let node = client.node\n\n  let sent = {}\n  let unbind = []\n  let prevConnected = false\n\n  if (messages.state !== false) {\n    unbind.push(\n      client.on('state', () => {\n        let details\n        if (client.state === 'connecting' && node.connection.url) {\n          details = {\n            'Node ID': node.localNodeId,\n            'Server': node.connection.url\n          }\n        } else if (client.connected && !prevConnected && node.remoteNodeId) {\n          prevConnected = true\n          details = {\n            'Server ID': node.remoteNodeId\n          }\n        } else if (!client.connected) {\n          prevConnected = false\n        }\n        showLog('state is ' + bold(client.state), details)\n      })\n    )\n  }\n\n  if (messages.role !== false) {\n    unbind.push(\n      client.on('role', () => {\n        showLog('tab role is ' + bold(client.role))\n      })\n    )\n  }\n\n  let cleaned = {}\n  let ignore = (messages.ignoreActions || []).reduce((all, i) => {\n    all[i] = true\n    return all\n  }, {})\n\n  if (messages.add !== false) {\n    unbind.push(\n      client.on('add', (action, meta) => {\n        if (meta.tab && meta.tab !== client.tabId) return\n        if (ignore[action.type]) return\n        if (meta.sync) sent[meta.id] = action\n        let message\n        if (action.type === 'logux/subscribe') {\n          message = 'subscribing to ' + bold(action.channel) + ' channel'\n          if (Object.keys(action).length === 2) {\n            showLog(message)\n          } else {\n            showLog(message, { Action: action })\n          }\n        } else if (action.type === 'logux/subscribed') {\n          showLog(\n            'subscribed to ' + bold(action.channel) + ' channel by server'\n          )\n        } else if (action.type === 'logux/unsubscribe') {\n          message = 'unsubscribed from channel ' + bold(action.channel)\n          if (Object.keys(action).length === 2) {\n            showLog(message)\n          } else {\n            showLog(message, { Action: action })\n          }\n        } else if (action.type === 'logux/processed') {\n          if (sent[action.id]) {\n            let processed = sent[action.id]\n            let details = {\n              'Processed Action': processed\n            }\n            if (processed.type === 'logux/subscribe') {\n              showLog(\n                'subscribed to ' + bold(processed.channel) + ' channel',\n                details\n              )\n            } else {\n              showLog(\n                'action ' + bold(processed.type) + ' was processed',\n                details\n              )\n            }\n            delete sent[action.id]\n          } else {\n            showLog('action ' + bold(action.id) + ' was processed')\n          }\n        } else if (action.type === 'logux/undo') {\n          if (action.action.type === 'logux/subscribe') {\n            message = 'subscription to ' + bold(action.action.channel)\n          } else {\n            message = 'action ' + bold(action.action.type)\n          }\n          message += ' was undone because of ' + bold(action.reason)\n          let details = {\n            'Reverted Action': action.action\n          }\n          if (Object.keys(action).length > 4) {\n            details['Undo Action'] = action\n          }\n          if (sent[action.id]) {\n            delete sent[action.id]\n          }\n          showLog(message, details)\n        } else {\n          let details = { Action: action, Meta: meta }\n          message = 'added '\n          if (meta.reasons.length === 0) {\n            cleaned[meta.id] = true\n            message += 'and cleaned '\n          }\n          message += bold(action.type) + ' action'\n          let { nodeId } = parseId(meta.id)\n          if (nodeId !== node.localNodeId) {\n            details.From = nodeId\n          }\n          showLog(message, details)\n        }\n      })\n    )\n  }\n\n  if (messages.user !== false) {\n    unbind.push(\n      client.on('user', userId => {\n        let message = 'user ID was changed to ' + bold(userId)\n        showLog(message, { 'Node ID': client.nodeId })\n      })\n    )\n  }\n\n  if (messages.clean !== false) {\n    unbind.push(\n      client.on('clean', (action, meta) => {\n        if (cleaned[meta.id]) {\n          delete cleaned[meta.id]\n          return\n        }\n        if (meta.tab && meta.tab !== client.id) return\n        if (ignore[action.type]) return\n        if (action.type.startsWith('logux/')) return\n        let message = 'cleaned ' + bold(action.type) + ' action'\n        showLog(message, { Action: action, Meta: meta })\n      })\n    )\n  }\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","\"use strict\";\n\n/* globals document:readonly */\nvar bundleURL = null;\n\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp):\\/\\/[^)\\n]+/g);\n\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\n\n\nfunction getOrigin(url) {\n  let matches = ('' + url).match(/(https?|file|ftp):\\/\\/[^/]+/);\n\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n\n  return matches[0];\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","\"use strict\";\n\nvar resolve = require('./bundle-manifest').resolve;\n\nmodule.exports = function (fromId, toId) {\n  return relative(dirname(resolve(fromId)), resolve(toId));\n};\n\nfunction dirname(_filePath) {\n  if (_filePath === '') {\n    return '.';\n  }\n\n  var filePath = _filePath[_filePath.length - 1] === '/' ? _filePath.slice(0, _filePath.length - 1) : _filePath;\n  var slashIndex = filePath.lastIndexOf('/');\n  return slashIndex === -1 ? '.' : filePath.slice(0, slashIndex);\n}\n\nfunction relative(from, to) {\n  if (from === to) {\n    return '';\n  }\n\n  var fromParts = from.split('/');\n\n  if (fromParts[0] === '.') {\n    fromParts.shift();\n  }\n\n  var toParts = to.split('/');\n\n  if (toParts[0] === '.') {\n    toParts.shift();\n  } // Find where path segments diverge.\n\n\n  var i;\n  var divergeIndex;\n\n  for (i = 0; (i < toParts.length || i < fromParts.length) && divergeIndex == null; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      divergeIndex = i;\n    }\n  } // If there are segments from \"from\" beyond the point of divergence,\n  // return back up the path to that point using \"..\".\n\n\n  var parts = [];\n\n  for (i = 0; i < fromParts.length - divergeIndex; i++) {\n    parts.push('..');\n  } // If there are segments from \"to\" beyond the point of divergence,\n  // continue using the remaining segments.\n\n\n  if (toParts.length > divergeIndex) {\n    parts.push.apply(parts, toParts.slice(divergeIndex));\n  }\n\n  return parts.join('/');\n}\n\nmodule.exports._dirname = dirname;\nmodule.exports._relative = relative;","import refresh from './refresh.svg'\nimport success from './success.svg'\nimport offline from './offline.svg'\nimport error from './error.svg'\n\nexport let badgeStyles = {\n  base: {\n    position: 'fixed',\n    width: '15.4em',\n    height: '4em',\n    lineHeight: '1.4',\n    margin: '1.5em',\n    paddingLeft: '4.2em',\n    opacity: '0.8',\n    borderRadius: '0.4em',\n    color: '#fff',\n    fontFamily: 'Helvetica Neue, sans-serif',\n    zIndex: '999',\n    backgroundPosition: '1.2em center',\n    backgroundRepeat: 'no-repeat',\n    backgroundSize: '1.8em'\n  },\n  text: {\n    display: 'table-cell',\n    verticalAlign: 'middle',\n    height: '4em'\n  },\n  synchronized: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + success + ')'\n  },\n  disconnected: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + offline + ')'\n  },\n  wait: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + offline + ')'\n  },\n  sending: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + refresh + ')'\n  },\n  error: {\n    backgroundColor: '#F42A2A',\n    backgroundImage: 'url(' + error + ')'\n  },\n  protocolError: {\n    backgroundColor: '#000',\n    backgroundImage: 'url(' + refresh + ')'\n  }\n}\n","import { MemoryStore, ClientNode, LocalPair, BaseNode, Log } from '@logux/core'\n\nimport {\n  CrossTabClient,\n  attention,\n  badgeEn,\n  confirm,\n  favicon,\n  status,\n  badge,\n  log\n} from '../../index.js'\nimport { badgeStyles } from '../../badge/styles/index.js'\nimport faviconOffline from './offline.png'\nimport faviconNormal from './normal.png'\nimport faviconError from './error.png'\n\nlet pair = new LocalPair(500)\n\nlet serverLog = new Log({\n  store: new MemoryStore(),\n  nodeId: 'server:uuid'\n})\nnew BaseNode('server:uuid', serverLog, pair.right)\n\nserverLog.on('add', (action, meta) => {\n  if (action.type !== 'logux/processed') {\n    setTimeout(() => {\n      serverLog.add({ type: 'logux/processed', id: meta.id })\n    }, 500)\n  }\n})\n\nlet client = new CrossTabClient({\n  subprotocol: location.hash.slice(1) || '1.0.0',\n  userId: '10',\n  server: 'wss://example.com/'\n})\n\nlet node = new ClientNode(client.node.localNodeId, client.log, pair.left)\nnode.connection.url = 'wss://example.com/'\nnode.emitter = client.node.emitter\nclient.node = node\n\nattention(client)\nconfirm(client)\nfavicon(client, {\n  normal: faviconNormal,\n  offline: faviconOffline,\n  error: faviconError\n})\nbadge(client, {\n  messages: badgeEn,\n  styles: badgeStyles\n})\nlog(client)\nstatus(client, s => {\n  document.all.status.innerText = s\n})\n\nlet count = 0\nfunction emoji(state) {\n  if (state === 'disconnected') {\n    return '😴'\n  } else if (state === 'connecting') {\n    return '🔌'\n  } else {\n    return '😊'\n  }\n}\nfunction role(value) {\n  return value.slice(0, 1).toUpperCase()\n}\nfunction updateTitle() {\n  document.title = emoji(client.state) + ' ' + role(client.role) + ' ' + count\n}\n\nclient.on('state', () => {\n  document.all.connection.checked = client.connected\n  updateTitle()\n})\nclient.on('role', () => {\n  updateTitle()\n  document.all.connection.disabled = client.role !== 'leader'\n})\nclient.on('add', action => {\n  if (action.type === 'TICK') count++\n  updateTitle()\n})\nclient.on('clean', action => {\n  if (action.type === 'TICK') count--\n  updateTitle()\n})\n\nclient.log\n  .each(action => {\n    if (action.type === 'TICK') count++\n  })\n  .then(() => {\n    updateTitle()\n  })\n\nclient.on('role', () => {\n  let isLeader = client.role === 'leader'\n  document.all.connection.disabled = !isLeader\n  document.all.disabled.style.display = isLeader ? 'none' : 'inline'\n})\n\nclient.start()\n\ndocument.all.connection.onchange = e => {\n  if (e.target.checked) {\n    client.node.connection.connect()\n  } else {\n    client.node.connection.disconnect()\n  }\n}\n\ndocument.all.add.onclick = () => {\n  client.log.add({ type: 'TICK' }, { reasons: ['tick'], sync: true })\n}\n\ndocument.all.clean.onclick = () => {\n  client.log.removeReason('tick')\n}\n\ndocument.all.error.onclick = () => {\n  setTimeout(() => {\n    client.log.add({ type: 'logux/undo', reason: 'error' })\n  }, 3000)\n}\n\ndocument.all.denied.onclick = () => {\n  setTimeout(() => {\n    client.log.add({ type: 'logux/undo', reason: 'denied' })\n  }, 3000)\n}\n\ndocument.all.serverError.onclick = () => {\n  setTimeout(() => {\n    pair.right.send(['error', 'wrong-format'])\n  }, 3000)\n}\n\ndocument.all.subprotocolError.onclick = () => {\n  client.node.syncError('wrong-subprotocol', {\n    supported: '2.x',\n    used: '1.0.0'\n  })\n}\n\nif (client.options.subprotocol === '1.0.1') {\n  document.all.subprotocolClient.disabled = true\n} else {\n  document.all.subprotocolClient.onclick = () => {\n    window.open(location.toString() + '#1.0.1', '_blank')\n  }\n}\n","export function track(client, id) {\n  if (client.processing[id]) return client.processing[id][0]\n\n  let resolveCallback, rejectCallback\n  let promise = new Promise((resolve, reject) => {\n    resolveCallback = resolve\n    rejectCallback = reject\n  })\n  client.processing[id] = [promise, resolveCallback, rejectCallback]\n\n  return promise\n}\n","export function attention(client) {\n  let doc = document\n  let originTitle = false\n  let unbind = []\n  let timeout = false\n\n  let restoreTitle = () => {\n    if (originTitle) {\n      doc.title = originTitle\n      originTitle = false\n    }\n  }\n\n  let blink = () => {\n    if (doc.hidden && !originTitle) {\n      originTitle = doc.title\n      doc.title = '* ' + doc.title\n    } else {\n      restoreTitle()\n    }\n\n    if (doc.hidden) timeout = setTimeout(blink, 1000)\n  }\n\n  let tabListener = () => {\n    if (!doc.hidden && timeout) {\n      timeout = clearTimeout(timeout)\n      restoreTitle()\n    }\n  }\n\n  if (doc && typeof doc.hidden !== 'undefined') {\n    unbind.push(\n      client.node.on('error', error => {\n        if (error.type !== 'timeout' && !timeout) {\n          blink()\n        }\n      })\n    )\n\n    unbind.push(\n      client.on('add', action => {\n        if (action.type === 'logux/undo' && action.reason && !timeout) {\n          blink()\n        }\n      })\n    )\n\n    document.addEventListener('visibilitychange', tabListener, false)\n    unbind.push(() => {\n      document.removeEventListener('visibilitychange', tabListener, false)\n    })\n  }\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n","export function favicon(client, links) {\n  let normal = links.normal\n  let offline = links.offline\n  let error = links.error\n\n  let unbind = []\n  let doc = document\n  let fav = false\n  let prevFav = false\n\n  function update() {\n    if (client.connected && prevFav !== normal) {\n      fav.href = prevFav = normal\n    } else if (\n      !client.connected &&\n      offline &&\n      prevFav !== offline &&\n      prevFav !== error\n    ) {\n      fav.href = prevFav = offline\n    }\n  }\n\n  function setError() {\n    if (error && prevFav !== error) {\n      fav.href = prevFav = error\n    }\n  }\n\n  if (doc) {\n    fav = doc.querySelector('link[rel~=\"icon\"]')\n\n    if (typeof normal === 'undefined') {\n      normal = fav ? fav.href : ''\n    }\n\n    if (!fav) {\n      fav = doc.createElement('link')\n      fav.rel = 'icon'\n      fav.href = ''\n      doc.head.appendChild(fav)\n    }\n\n    unbind.push(client.on('state', update))\n    update()\n\n    unbind.push(\n      client.on('add', action => {\n        if (action.type === 'logux/undo' && action.reason) setError()\n      })\n    )\n\n    unbind.push(\n      client.node.on('error', err => {\n        if (err.type !== 'timeout') setError()\n      })\n    )\n  }\n\n  return () => {\n    for (let i of unbind) i()\n  }\n}\n"],"names":["$parcel$interopDefault","a","__esModule","default","$457604fc98823e7c233c394ad495f88a$var$mapping","id","resolved","Error","pairs","keys","Object","i","length","JSON","parse","$c60c7da9a4109e9736091b6952bab8a6$export$actionEvents","emitter","event","action","meta","emit","type","$c60c7da9a4109e9736091b6952bab8a6$export$Log","constructor","opts","this","nodeId","lastTime","sequence","store","events","args","forEach","on","cb","push","filter","listener","newId","generateId","time","parseInt","reasons","keepLast","removeReason","olderThan","action2","byId","addedMeta","add","now","Date","each","callback","order","Promise","resolve","async","nextPage","get","result","page","entries","entry","next","bind","diff","k","remove","changeMeta","reason","criteria","$ab72e4c5e269f6d798400f37e3bac2f9$export$isFirstOlder","firstMeta","secondMeta","first","split","second","firstNode","secondNode","firstCounter","secondCounter","firstNodeTime","secondNodeTime","$e0aa73bb061ed71d6f9aafb5d83c2ed3$export$WsConnection","url","Class","connected","WebSocket","init","ws","onerror","error","onclose","onmessage","data","connect","undefined","onopen","disconnect","close","send","message","readyState","OPEN","stringify","err","received","$273289050e4def2546a0571a3d47e328$var$checkIndex","index","indexes","added","$273289050e4def2546a0571a3d47e328$var$forEachIndex","$273289050e4def2546a0571a3d47e328$var$isDefined","$273289050e4def2546a0571a3d47e328$var$insert","lastAdded","$273289050e4def2546a0571a3d47e328$var$eject","start","end","middle","otherAdded","splice","$273289050e4def2546a0571a3d47e328$var$find","list","value","$273289050e4def2546a0571a3d47e328$export$MemoryStore","lastReceived","lastSent","otherMeta","indexList","j","findIndex","item","created","indexed","slice","key","removed","reasonPos","indexOf","c","youngerThan","minAdded","maxAdded","removedAdded","map","m","removing","includes","sent","values","$6ae039d94f7ab2747b36aaa82b65b509$export$LoguxError","options","supported","used","super","name","description","describe","captureStackTrace","$82c578a9349009b5095ee34cac304065$var$auth","node","token","auth","authenticated","remoteHeaders","access","unauthenticated","onMessage","sendError","destroy","e","$82c578a9349009b5095ee34cac304065$var$checkProtocol","ver","remoteProtocol","minProtocol","$82c578a9349009b5095ee34cac304065$var$emitEvent","$e1338eda98b983c2f73f6cfabae5dac9$var$NOT_TO_THROW","timeout","$e1338eda98b983c2f73f6cfabae5dac9$var$BEFORE_AUTH","$e1338eda98b983c2f73f6cfabae5dac9$var$syncMappedEvent","lastAddedCache","outMap","changed","sendSync","$e1338eda98b983c2f73f6cfabae5dac9$export$BaseNode","log","connection","remoteNodeId","remoteSubprotocol","localProtocol","localNodeId","ping","timeFix","syncing","state","timeouts","throwsError","unbind","onAdd","onConnecting","onConnect","onDisconnect","initialized","initializing","initialize","localHeaders","catch","waitFor","clearTimeout","pingTimeout","endTimeout","setLocalHeaders","headers","sendHeaders","msg","delayPing","setState","outFilter","syncError","startTimeout","ms","setTimeout","shift","sendPing","lastSynced","promises","then","r","all","syncSinceQuery","setLastSent","setLastSynced","setLastReceived","synced","getLastSynced","getLastAdded","sendDuilian","$e1338eda98b983c2f73f6cfabae5dac9$var$DUILIANS","duilianMessage","line","prototype","sendConnect","subprotocol","fixTime","connectSended","sendConnected","connectMessage","baseTime","syncSince","connectedMessage","authTime","roundTrip","Math","floor","originMeta","unshift","concat","sendSynced","syncMessage","join","process","inMap","meta2","filtered","inFilter","res","syncedMessage","pingMessage","pongMessage","sendDebug","debugMessage","errorMessage","headersMessage","金木水火土","$e0be7339bd226752908001fe3ab95cfe$var$DEFAULT_OPTIONS","$e0be7339bd226752908001fe3ab95cfe$export$ClientNode","$80ab5d1cebc30408a179f27d1c44cd4b$var$LocalConnection","pair","other","right","left","delay","$b9e23c9aad5a62431e716a1e3eff942a$var$DEFAULT_OPTIONS","minDelay","maxDelay","attempts","Infinity","$b9e23c9aad5a62431e716a1e3eff942a$var$FATAL_ERRORS","$b9e23c9aad5a62431e716a1e3eff942a$export$Reconnect","reconnecting","connecting","reconnect","timer","visibility","document","hidden","navigator","onLine","window","addEventListener","removeEventListener","nextDelay","base","rand","random","deviation","min","$000967cfece7e4885fc013b7f2a605bc$export$parseId","parts","userId","clientId","$f05e98d011634eb9de1072eaf6bb3b6e$export$status","client","observable","disconnected","wait","old","duration","processing","setSynchronized","changeState","sync","$33c7c2b81ee276f407f8b760b1b6260c$var$injectStyles","element","styles","style","$33c7c2b81ee276f407f8b760b1b6260c$var$RESET","boxSizing","textIndent","textTransform","wordSpacing","letterSpacing","fontStyle","fontVariant","fontWeight","lineHeight","$b71c64939dd7d21f92554fb60c5ee604$export$nanoid","size","bytes","crypto","getRandomValues","Uint8Array","byte","toString","toUpperCase","$48c4eb20554decc7e1044c8d13ccf8bd$export$LoguxUndoError","$8e9af09a9283a12a397c99eecfac5b87$var$ALLOWED_META","$8e9af09a9283a12a397c99eecfac5b87$var$tabPing","localStorage","setItem","prefix","tabId","$8e9af09a9283a12a397c99eecfac5b87$var$cleanTabActions","isLocalStorage","removeItem","$57d23f88e70dc6b79069ec7284a7cb1b$var$storageKey","$57d23f88e70dc6b79069ec7284a7cb1b$var$sendToTabs","json","console","role","$57d23f88e70dc6b79069ec7284a7cb1b$var$getLeader","getItem","$57d23f88e70dc6b79069ec7284a7cb1b$var$leaderPing","$57d23f88e70dc6b79069ec7284a7cb1b$var$onDeadLeader","$57d23f88e70dc6b79069ec7284a7cb1b$var$setState","$57d23f88e70dc6b79069ec7284a7cb1b$var$startElection","$57d23f88e70dc6b79069ec7284a7cb1b$var$watchForLeader","watching","$57d23f88e70dc6b79069ec7284a7cb1b$var$isActiveLeader","roleTimeout","$57d23f88e70dc6b79069ec7284a7cb1b$var$setRole","leadership","setInterval","unloading","leaderPing","elections","clearInterval","leader","leaderTimeout","electionDelay","$5b9e0f6cb671d5caf0faa29ffef52dc0$var$block","returnValue","$f21439849128c3474f28f2f6d17ce370$var$bold","string","$f21439849128c3474f28f2f6d17ce370$var$showLog","text","details","Array","from","match","_","groupCollapsed","groupEnd","$6171cae8154909f81c5d7962291cdbaf$var$bundleURL","matches","stack","replace","$6171cae8154909f81c5d7962291cdbaf$var$getBundleURL","$d8e73c1a0305a00754e02697844bc85c$var$resolve","$d8e73c1a0305a00754e02697844bc85c$var$dirname","_filePath","filePath","slashIndex","lastIndexOf","$d8e73c1a0305a00754e02697844bc85c$var$relative","to","fromParts","divergeIndex","toParts","apply","fromId","toId","_dirname","_relative","$087a05d37f27b7c937524b3dbf1d66b0$export$badgeStyles","position","width","height","margin","paddingLeft","opacity","borderRadius","color","fontFamily","zIndex","backgroundPosition","backgroundRepeat","backgroundSize","display","verticalAlign","synchronized","backgroundColor","backgroundImage","$5395fb2231324673681f7b0c6345f98e$$interop$default","$8b1d46243a56382797fca4c6055a574b$$interop$default","sending","$017d4be7a81227e21d7002813098a3db$$interop$default","protocolError","$92cf3332670dc04ed77c0caca38ef406$var$pair","$92cf3332670dc04ed77c0caca38ef406$var$serverLog","$92cf3332670dc04ed77c0caca38ef406$var$client","lastId","getClientId","nextLog","resubscribe","last","subscriptions","subscribing","unsubscribing","unsubscription","subscribers","subscription","channel","channels","tabPing","tabTimeout","pinging","server","test","allowDangerousProtocol","unbindEnvTest","env","since","onUnload","cleanPrevActions","resolveCallback","rejectCallback","promise","reject","changeUser","wasConnected","clean","leaderState","tab","onStorage","subprotocolKey","newValue","isArray","compare","leftParts","rightParts","leftNumber","rightNumber","$57d23f88e70dc6b79069ec7284a7cb1b$var$compareSubprotocols","location","hash","$92cf3332670dc04ed77c0caca38ef406$var$node","doc","originTitle","restoreTitle","title","blink","tabListener","update","links","normal","offline","fav","prevFav","href","setError","querySelector","createElement","rel","head","appendChild","messages","widget","setAttribute","top","transform","pos","$33c7c2b81ee276f407f8b760b1b6260c$var$setPosition","show","innerHTML","denied","body","$33c7c2b81ee276f407f8b760b1b6260c$export$badgeEn","prevConnected","Server","cleaned","ignore","ignoreActions","reduce","Action","processed","Meta","From","user","startsWith","s","status","innerText","$92cf3332670dc04ed77c0caca38ef406$var$count","$92cf3332670dc04ed77c0caca38ef406$var$updateTitle","checked","disabled","isLeader","onchange","target","onclick","serverError","subprotocolError","subprotocolClient","open"],"version":3,"file":"index.9d7ed22a.js.map"}